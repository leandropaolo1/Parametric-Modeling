import math

import Draft
import FreeCAD as App
import FreeCADGui as Gui
from PySide import QtCore

hexSeparation = 0.2
hexExtrusion = -2
hexRadius = 2
planeOffset = -3
userSheetLabel = "EditMe"
autoGeneratedLabel = "AutoGenerated"


class SpreadSheet:
    def __init__(self):
        self.hexSeparation = hexSeparation
        self.hexExtrusion = hexExtrusion
        self.hexRadius = hexRadius
        self.planeOffset = planeOffset
        self.name = userSheetLabel
        self.aliases = {}  # last aliases used (cell map)

    def _create_or_get_sheet(self, label: str):
        """Create or fetch a Spreadsheet::Sheet by label and prime self.set & self.sheet."""
        doc = App.ActiveDocument
        if not doc:
            raise RuntimeError("No active FreeCAD document.")
        sheet = doc.getObject(label)
        if sheet is None:
            sheet = doc.addObject("Spreadsheet::Sheet", label)
        sheet.setColumnWidth("A", 150)
        self.set = sheet.set
        self.sheet = sheet
        self.name = label
        return sheet

    def _write_aliases(self, aliases: dict):
        """Register aliases on the current sheet."""
        if not self.sheet:
            raise RuntimeError("Sheet not initialized.")
        for alias_name, cell in aliases.items():
            self.sheet.setAlias(cell, alias_name)
        self.aliases = aliases

    def userSpreadSheet(self):
        sheet = self._create_or_get_sheet(userSheetLabel)
        setc = self.set

        aliases = {
            "radius": "B2",
            "separation": "B3",
            "height": "B6",
            "planeOffset": "B7",
        }

        self._write_aliases(aliases)

        setc("A1", "User Variables")
        setc("A2", "Hexagon Radius:")
        setc(aliases["radius"], str(self.hexRadius))
        setc("A3", "Hexagon Separation:")
        setc(aliases["separation"], str(self.hexSeparation))
        setc("A6", "Grid Height:")
        setc(aliases["height"], str(self.hexExtrusion))
        setc("A7", "Plane Offset:")
        setc(aliases["planeOffset"], str(planeOffset))

        App.ActiveDocument.recompute()
        return sheet

    def compute(self, offset2D):
        sheet = self._create_or_get_sheet(autoGeneratedLabel)
        setc = self.set

        aliases = {
            "radius": "B2",
            "separation": "B3",
            "height": "B6",
            "planeOffset": "B7",
            "width": "B4",
            "length": "B5",
            "tweakX": "B8",
            "tweakY": "B9",
            "tweakZ": "B10",
            "xInterval": "E2",
            "yInterval": "E3",
            "firstX": "E4",
            "firstY": "E5",
            "countX": "E6",
            "countY": "E7",
            "array2XPos": "E8",
            "array2YPos": "E9",
        }

        self._write_aliases(aliases)

        setc("A1", "Auto-Generated Variables")
        setc("D1", "Calculated Values")
        setc("A2", "Hexagon Radius:")
        setc(aliases["radius"], f"={userSheetLabel}.radius")
        setc("A3", "Hexagon Separation:")
        setc(aliases["separation"], f"={userSheetLabel}.separation")
        setc("A6", "Grid Height:")
        setc(aliases["height"], f"={userSheetLabel}.height")

        bbox = offset2D.Shape.BoundBox
        maxOffsetLength = bbox.XMax - bbox.XMin
        maxOffsetWidth = bbox.YMax - bbox.YMin
        offset2DZMin = bbox.ZMin

        setc("A4", "Grid Width:")
        setc(aliases["width"], str(maxOffsetWidth))
        setc("A5", "Grid Length:")
        setc(aliases["length"], str(maxOffsetLength))
        setc("A8", "Tweak X:")
        setc(aliases["tweakX"], str(bbox.XMin))
        setc("A9", "Tweak Y:")
        setc(aliases["tweakY"], str(bbox.YMin))
        setc("A10", "Tweak Z:")
        setc(aliases["tweakZ"], str(offset2DZMin))

        setc("D2", "X Interval:")
        setc(aliases["xInterval"], "=2*sin(60 deg)*(B2*2 + (B3 - 0.267949*B2))")
        setc("D3", "Y Interval:")
        setc(aliases["yInterval"], "=2*B2 + (B3 - 0.267949*B2)")
        setc("D4", "First X:")
        setc(aliases["firstX"], "=B2")
        setc("D5", "First Y:")
        setc(aliases["firstY"], "=B2")
        setc("D6", "Count X:")
        setc(aliases["countX"], "=round(B5 / E2) + 2")
        setc("D7", "Count Y:")
        setc(aliases["countY"], "=round(B4 / E3) + 2")
        setc("D8", "Array2 XPos:")
        setc(aliases["array2XPos"], "=sin(60 deg)*(B2*2 + B3 - 0.267949*B2)")
        setc("D9", "Array2 YPos:")
        setc(aliases["array2YPos"], "=E3/2")

        App.ActiveDocument.recompute()
        return sheet

    def write(self):
        """Kept for compatibility; recompute and return the active sheet."""
        if not self.sheet:
            raise RuntimeError(
                "No sheet to write to. Call userSheet() or autoGeneratedLabel() first."
            )
        App.ActiveDocument.recompute()
        return self.sheet


class ShapePattern:
    def __init__(self, userSheet, autoGeneratedSheet, offset2D, type):
        self.autoGeneratedSheet = autoGeneratedSheet
        self.userSheet = userSheet
        self.offset2D = offset2D
        self.type = type or "hexagons"  # honor the arg, default if None
        self.fusedArrays = None

    def supportShape(self, src_obj, subname):
        """
        Return the exact Face referenced by `subname` from `src_obj.Shape`,
        tolerating odd formats (e.g. ('Face3',), 'Face', etc.).
        """
        shp = src_obj.Shape

        # Normalize subname to a simple string like "FaceN"
        if isinstance(subname, (tuple, list)) and subname:
            subname = subname[0]

        # 1) Try direct lookup (best case)
        try:
            return shp.getElement(subname)
        except Exception:
            pass

        # 2) Parse trailing digits and index the Faces list
        try:
            import re

            m = re.search(r"(\d+)$", str(subname))
            if m:
                i = int(m.group(1)) - 1
                if 0 <= i < len(shp.Faces):
                    return shp.Faces[i]
        except Exception:
            pass

        # 3) Fallback: first face
        return shp.Faces[0] if shp.Faces else None

    def createShapeArray(self):
        doc = App.ActiveDocument

        # ---- Defer recomputes until the end
        had_autorc = getattr(doc, "AutoRecompute", True)
        if hasattr(doc, "AutoRecompute"):
            doc.AutoRecompute = False
        try:
            # 1) Hex profile driven by user sheet
            hexagon = doc.addObject("Part::RegularPolygon", "HoneycombHexagon")
            hexagon.Polygon = 6
            hexagon.setExpression("Circumradius", f"{userSheetLabel}.radius")

            # 2) One extrude, reused via links
            hex_extrude = doc.addObject("Part::Extrusion", "ExtrudedHexagon")
            hex_extrude.Base = hexagon
            hex_extrude.Solid = True
            hex_extrude.setExpression("LengthFwd", f"{userSheetLabel}.height")
            hex_extrude.setExpression(
                "Placement.Base.x", f"{autoGeneratedLabel}.tweakX"
            )
            hex_extrude.setExpression(
                "Placement.Base.y", f"{autoGeneratedLabel}.tweakY"
            )

            # 3) Two ortho arrays as *links* (memory-friendly)
            row1 = Draft.make_ortho_array(
                hex_extrude,
                v_x=App.Vector(1, 0, 0),
                v_y=App.Vector(0, 1, 0),
                n_x=1,
                n_y=1,
                use_link=True,
            )

            row2 = Draft.make_ortho_array(
                hex_extrude,
                v_x=App.Vector(1, 0, 0),
                v_y=App.Vector(0, 1, 0),
                n_x=1,
                n_y=1,
                use_link=True,
            )

            # Position at ZMin of the support face
            zmin = self.offset2D.Shape.BoundBox.ZMin
            row1.Placement.Base.z = zmin  # type: ignore
            row2.Placement.Base.z = zmin  # type: ignore

            # Drive both arrays from the auto sheet
            row2.setExpression("Placement.Base.x", f"{autoGeneratedLabel}.array2XPos")  # type: ignore
            row2.setExpression("Placement.Base.y", f"{autoGeneratedLabel}.array2YPos")  # type: ignore
            for arr in (row1, row2):
                arr.setExpression("IntervalX.x", f"{autoGeneratedLabel}.xInterval")  # type: ignore
                arr.setExpression("IntervalY.y", f"{autoGeneratedLabel}.yInterval")  # type: ignore
                arr.setExpression("NumberX", f"{autoGeneratedLabel}.countX")  # type: ignore
                arr.setExpression("NumberY", f"{autoGeneratedLabel}.countY")  # type: ignore

            # 4) Use a Compound instead of a MultiFuse (faster, enough for cutting)
            compound = doc.addObject("Part::Compound", "HoneycombCompound")
            compound.Links = [row1, row2]  # accepts arrays/links directly

            # Keep sources hidden; avoid GUI churn mid-build
            hexagon.ViewObject.Visibility = False
            row1.ViewObject.Visibility = False  # type: ignore
            row2.ViewObject.Visibility = False  # type: ignore

        finally:
            if hasattr(doc, "AutoRecompute"):
                doc.AutoRecompute = had_autorc
            doc.recompute()  # one-shot recompute

        # Store and hand back the single tool weâ€™ll cut with
        self.fusedArrays = compound
        return compound

    @staticmethod
    def extrude(shape, length):
        # kept here in case you still want a local helper
        extruded = App.ActiveDocument.addObject("Part::Extrusion", "Extruded")
        extruded.Base = shape
        extruded.DirMode = "Normal"
        extruded.LengthFwd = length if length > 0 else 0
        extruded.LengthRev = -length if length < 0 else 0
        extruded.Solid = True
        return extruded


class Folders:
    def __init__(self):
        pass

    @staticmethod
    def create(
        container_name: str = "Honeycomb",
        object_names=("EditMe", "Offset2D", "Extruded", "Fused_Arrays"),
        body_name: str = "Body",
        binder_name: str = "Binder",
        use_part: bool = False,
        include_binder_link: bool = True,
    ):
        """
        Create (or reuse) a top-level container and place the generated objects inside it.
        - If use_part is True, an App::Part is created so placement is unified.
        - The Binder stays inside the Body; we optionally show it via an App::Link.
        - Idempotent: wonâ€™t re-add already grouped objects or duplicate the link.
        Returns: (container, binder_link or None)
        """
        doc = App.ActiveDocument
        if doc is None:
            raise RuntimeError("No active document.")

        # Pause recompute while we shuffle the tree
        had_autorecompute = getattr(doc, "AutoRecompute", True)
        if hasattr(doc, "AutoRecompute"):
            doc.AutoRecompute = False

        try:
            # 1) Create or reuse the container
            existing = doc.getObject(container_name)
            if existing and (
                existing.TypeId in ("App::DocumentObjectGroup", "App::Part")
            ):
                container = existing
            else:
                # If a different object with that name exists, rename it to avoid conflict
                if existing and existing.TypeId not in (
                    "App::DocumentObjectGroup",
                    "App::Part",
                ):
                    existing.Label = existing.Label + "_old"
                ctype = "App::Part" if use_part else "App::DocumentObjectGroup"
                container = doc.addObject(ctype, container_name)
                container.Label = container_name

            # 2) Optionally place the Body inside the Part (not the Group)
            body = doc.getObject(body_name)
            if use_part and body and body not in getattr(container, "Group", []):
                container.addObject(body)

            # Helper: add an object if it exists and isnâ€™t already inside
            def _safe_add(obj):
                if not obj:
                    return
                if obj is container:
                    return
                current_group = getattr(container, "Group", [])
                if obj not in current_group:
                    container.addObject(obj)

            # 3) Add requested objects (skip Body if already handled)
            for name in object_names:
                obj = doc.getObject(name)
                if use_part and obj is body:
                    continue
                _safe_add(obj)

            # 4) Optionally expose the Binder via an App::Link (donâ€™t move it)
            binder_link = None
            binder = doc.getObject(binder_name)
            if include_binder_link and binder:
                link_name = f"{binder_name}_Link"
                binder_link = doc.getObject(link_name)
                if binder_link is None:
                    binder_link = doc.addObject("App::Link", link_name)
                # Only update if itâ€™s not already linked or links elsewhere
                if getattr(binder_link, "LinkedObject", None) is not binder:
                    binder_link.LinkedObject = binder
                _safe_add(binder_link)

            doc.recompute()
            return container, binder_link

        finally:
            if hasattr(doc, "AutoRecompute"):
                doc.AutoRecompute = had_autorecompute
            doc.recompute()


class Plane:
    def __init__(self):
        pass

    def createShapeBinder(self):
        sel_ex = Gui.Selection.getSelectionEx()
        if not sel_ex or not sel_ex[0].SubElementNames:
            raise Exception("Error: Select a face to create the honeycomb grid on.")

        self.doc = App.ActiveDocument
        sel = sel_ex[0]
        src_obj = sel.Object
        subname = sel.SubElementNames[0]

        def findBody(o):
            visited = set()
            queue = list(getattr(o, "InList", []))
            while queue:
                p = queue.pop(0)
                if p in visited:
                    continue
                visited.add(p)
                if getattr(p, "TypeId", "") == "PartDesign::Body":
                    return p
                # keep walking upward
                queue.extend(getattr(p, "InList", []))
            return None

        body = findBody(src_obj)
        self.body = body

        if body:
            binder = body.newObject("PartDesign::SubShapeBinder", "Binder")
        else:
            binder = self.doc.addObject("PartDesign::SubShapeBinder", "Binder")

        binder.Support = [(src_obj, subname)]
        binder.ViewObject.Visibility = False

        self.doc.recompute()
        return binder

    def createOffset2D(self, subShapeBinder):
        offset2D = App.activeDocument().addObject("Part::Offset2D", "Offset2D")
        offset2D.Source = subShapeBinder
        offset2D.setExpression("Value", f"{userSheetLabel}.planeOffset")
        App.activeDocument().recompute()
        offset2D.ViewObject.Visibility = False
        return offset2D

    def extrude(self, shape, length=None, spreadsheet=None):
        print(type(spreadsheet))

        extrusion = App.ActiveDocument.addObject("Part::Extrusion", "Extruded")
        extrusion.Base = shape
        extrusion.DirMode = "Normal"
        extrusion.Solid = True

        if length:
            L = float(length) if hasattr(length, "Value") else float(length)
            extrusion.LengthFwd = L if L > 0 else 0
            extrusion.LengthRev = -L if L < 0 else 0
            return

        length = float(spreadsheet.height)  # type: ignore
        sheet_label = spreadsheet.Name  # type: ignore
        expr_mm = f"({sheet_label}.height * 1 mm)"
        extrusion.setExpression("LengthFwd", f"max({expr_mm}, 0 mm)")
        extrusion.setExpression("LengthRev", f"max(-{expr_mm}, 0 mm)")
        return extrusion

    def alignFace(self, reference, target):
        referenceRotation = self.getGlobalRotation(reference)
        targetRotation = self.getGlobalRotation(target)
        deltaRotation = self.getDeltaRotation(referenceRotation, targetRotation)
        target.Placement.Rotation = referenceRotation

    @staticmethod
    def getGlobalRotation(plane):
        globalRotation = getattr(plane, "getGlobalPlacement", None)
        if callable(globalRotation):
            return globalRotation().Rotation
        return plane.Placement.Rotation

    @staticmethod
    def getDeltaRotation(reference, target):
        baseRotation = App.Rotation(reference)
        baseRotation.invert()
        return baseRotation.multiply(target)


def delete_after_delay(objs, delay_ms=10000):
    """Delete the given objects after delay_ms milliseconds."""

    def _delete():
        doc = App.ActiveDocument
        for obj in objs:
            try:
                if obj and obj in doc.Objects:
                    doc.removeObject(obj.Name)
            except Exception as e:
                print(f"Could not delete {obj.Name}: {e}")
        doc.recompute()

    QtCore.QTimer.singleShot(delay_ms, _delete)


def main():
    # 1) Build user spreadsheet and binder
    sheet = SpreadSheet()
    userSpreadsheet = sheet.userSpreadSheet()
    plane = Plane()
    binder = plane.createShapeBinder()

    # 2) Offsets and extrusions
    offset2D_a = plane.createOffset2D(binder)
    offset2D_b = plane.createOffset2D(binder)
    plane.alignFace(binder, offset2D_a)
    plane.alignFace(binder, offset2D_b)

    extrusion_a = plane.extrude(offset2D_a, spreadsheet=userSpreadsheet)
    extrusion_b = plane.extrude(offset2D_b, spreadsheet=userSpreadsheet)

    # 3) Auto sheet + hex pattern
    autoGeneratedSpreadsheet = sheet.compute(offset2D=offset2D_a)
    hexagons = ShapePattern(
        userSheet=userSpreadsheet,
        autoGeneratedSheet=autoGeneratedSpreadsheet,
        offset2D=offset2D_a,
        type="hexagons",
    )

    fused = hexagons.createShapeArray()
    # hexagons.alignShapes()

    # Expose arrays so we can delete them too
    row1, row2 = fused.Links
    compound = fused

    doc = plane.doc

    cutA = doc.addObject("Part::Cut", "Cut_OffsetA_minus_Hexagons")
    cutA.Base = extrusion_a
    cutA.Tool = fused

    cutB = doc.addObject("Part::Cut", "Cut_OffsetB_minus_Body")
    cutB.Base = plane.body
    cutB.Tool = extrusion_b

    doc.recompute()
    Gui.SendMsgToActiveView("ViewFit")

    """
    # --- cleanup after 10 sec ---
    delete_after_delay(
        [offset2D_a, offset2D_b,
         extrusion_a, extrusion_b,
         row1, row2, compound,
         cutA, cutB],
        delay_ms=20000
    )
    """


if __name__ == "__main__":
    main()
