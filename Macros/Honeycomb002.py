import FreeCADGui as Gui
import FreeCAD as App
import Draft
import math
from PySide import QtCore



hexSeparation       = .2
hexExtrusion        = -2
hexRadius           = 2
planeOffset         = -3
userSheetLabel      = 'EditMe'
autoGeneratedLabel  = 'AutoGenerated'



class SpreadSheet:
    def __init__(self):
        
        self.hexSeparation = hexSeparation
        self.hexExtrusion  = hexExtrusion
        self.hexRadius     = hexRadius
        self.planeOffset   = planeOffset
        self.name       = userSheetLabel
        self.aliases    = {}             # last aliases used (cell map)

    def _create_or_get_sheet(self, label: str):
        """Create or fetch a Spreadsheet::Sheet by label and prime self.set & self.sheet."""
        doc = App.ActiveDocument
        if not doc:
            raise RuntimeError("No active FreeCAD document.")
        sheet = doc.getObject(label)
        if sheet is None:
            sheet = doc.addObject("Spreadsheet::Sheet", label)
        sheet.setColumnWidth('A', 150)
        self.set   = sheet.set
        self.sheet = sheet
        self.name  = label
        return sheet

    def _write_aliases(self, aliases: dict):
        """Register aliases on the current sheet."""
        if not self.sheet:
            raise RuntimeError("Sheet not initialized.")
        for alias_name, cell in aliases.items():
            self.sheet.setAlias(cell, alias_name)
        self.aliases = aliases

    def userSpreadSheet(self):
        sheet = self._create_or_get_sheet(userSheetLabel)
        setc  = self.set


        aliases = {
            'radius':      'B2',
            'separation':  'B3',
            'height':      'B6',
            'planeOffset': 'B7',
        }
        
        self._write_aliases(aliases)

        setc('A1', 'User Variables')
        setc('A2', 'Hexagon Radius:');     setc(aliases['radius'],      str(self.hexRadius))
        setc('A3', 'Hexagon Separation:'); setc(aliases['separation'],  str(self.hexSeparation))
        setc('A6', 'Grid Height:');        setc(aliases['height'],      str(self.hexExtrusion))
        setc('A7', 'Plane Offset:');       setc(aliases['planeOffset'], str(planeOffset))

        App.ActiveDocument.recompute()
        return sheet

    def computingSpreadSheet(self, offset2D):
        sheet = self._create_or_get_sheet(autoGeneratedLabel)
        setc  = self.set

        aliases = {
            'radius':      'B2',
            'separation':  'B3',
            'height':      'B6',
            'planeOffset': 'B7',

            'width':       'B4',
            'length':      'B5',
            'tweakX':      'B8',
            'tweakY':      'B9',
            'tweakZ':      'B10',

            'xInterval':   'E2',
            'yInterval':   'E3',
            'firstX':      'E4',
            'firstY':      'E5',
            'countX':      'E6',
            'countY':      'E7',
            'array2XPos':  'E8',
            'array2YPos':  'E9',
        }
        
        self._write_aliases(aliases)

        setc('A1', 'Auto-Generated Variables')
        setc('D1', 'Calculated Values')
        setc('A2', 'Hexagon Radius:');     setc(aliases['radius'],     f'={userSheetLabel}.radius')
        setc('A3', 'Hexagon Separation:'); setc(aliases['separation'], f'={userSheetLabel}.separation')
        setc('A6', 'Grid Height:');        setc(aliases['height'],     f'={userSheetLabel}.height')

        bbox             = offset2D.Shape.BoundBox
        maxOffsetLength  = bbox.XMax - bbox.XMin
        maxOffsetWidth   = bbox.YMax - bbox.YMin
        offset2DZMin     = bbox.ZMin

        setc('A4',  'Grid Width:');   setc(aliases['width'],   str(maxOffsetWidth))
        setc('A5',  'Grid Length:');  setc(aliases['length'],  str(maxOffsetLength))
        setc('A8',  'Tweak X:');      setc(aliases['tweakX'],  str(bbox.XMin))
        setc('A9',  'Tweak Y:');      setc(aliases['tweakY'],  str(bbox.YMin))
        setc('A10', 'Tweak Z:');      setc(aliases['tweakZ'],  str(offset2DZMin))

        setc('D2', 'X Interval:');   setc(aliases['xInterval'],  '=2*sin(60 deg)*(B2*2 + (B3 - 0.267949*B2))')
        setc('D3', 'Y Interval:');   setc(aliases['yInterval'],  '=2*B2 + (B3 - 0.267949*B2)')
        setc('D4', 'First X:');      setc(aliases['firstX'],     '=B2')
        setc('D5', 'First Y:');      setc(aliases['firstY'],     '=B2')
        setc('D6', 'Count X:');      setc(aliases['countX'],     '=round(B5 / E2) + 2')
        setc('D7', 'Count Y:');      setc(aliases['countY'],     '=round(B4 / E3) + 2')
        setc('D8', 'Array2 XPos:');  setc(aliases['array2XPos'], '=sin(60 deg)*(B2*2 + B3 - 0.267949*B2)')
        setc('D9', 'Array2 YPos:');  setc(aliases['array2YPos'], '=E3/2')

        App.ActiveDocument.recompute()
        return sheet

    def write(self):
        """Kept for compatibility; recompute and return the active sheet."""
        if not self.sheet:
            raise RuntimeError("No sheet to write to. Call userSheet() or autoGeneratedLabel() first.")
        App.ActiveDocument.recompute()
        return self.sheet


class ShapePattern():
    def __init__(self, userSheet, autoGeneratedSheet, offset2D, type):
        self.autoGeneratedSheet = autoGeneratedSheet
        self.userSheet = userSheet
        self.offset2D = offset2D
        self.type = type or 'hexagons'   # honor the arg, default if None
        self.fusedArrays = None

    def alignShapes(self):
        import math
        doc = App.ActiveDocument
        if not self.fusedArrays:
            return

        # --- stop expressions from fighting placement
        for obj in [getattr(self, "_hex_extrude", None), *(getattr(self, "_arrays", ()) or [])]:
            if not obj: 
                continue
            for key in ('Placement.Base.x','Placement.Base.y','Placement.Base.z','Placement'):
                try: obj.clearExpression(key)
                except Exception: pass

        # --- use the binder's baked face (global)
        binder = self.offset2D.Source
        if not hasattr(binder, "Shape") or not binder.Shape.Faces:
            return
        face = binder.Shape.Faces[0]
        # global normal & point
        gp = binder.getGlobalPlacement()
        n = gp.Rotation.multVec(face.normalAt(0.5,0.5));  n.normalize()
        p0 = gp.multVec(face.CenterOfMass)

        # stable in-plane direction
        gx = App.Vector(1,0,0)
        u = gx - n.multiply(gx.dot(n))
        if u.Length < 1e-9:
            gx = App.Vector(0,1,0); u = gx - n.multiply(gx.dot(n))
        u.normalize()

        # --- absolute orientation: +Z -> n, then untwist so +X -> u
        pl = self.fusedArrays.Placement
        self.fusedArrays.Placement = App.Placement(pl.Base, App.Rotation())
        Rz = App.Rotation(App.Vector(0,0,1), n)
        x_after = Rz.multVec(App.Vector(1,0,0))
        s = n.dot(x_after.cross(u)); c = x_after.dot(u)
        twist = math.degrees(math.atan2(s, c))
        self.fusedArrays.Placement.Rotation = App.Rotation(n, twist).multiply(Rz)

        # --- seat lowest vertex onto the face plane
        curP = self.fusedArrays.Placement
        verts = [v.Point for v in self.fusedArrays.Shape.Vertexes]
        min_proj = min(n.dot(curP.multVec(v)) for v in verts)
        lift = n.dot(p0) - min_proj
        self.fusedArrays.Placement.Base = self.fusedArrays.Placement.Base + n.multiply(lift)

        # --- slide in-plane to Offset2D center (global)
        off = self.offset2D.Shape.copy()
        off.Placement = self.offset2D.getGlobalPlacement()
        target_c = off.BoundBox.Center

        curP = self.fusedArrays.Placement
        hc_c_global = curP.multVec(self.fusedArrays.Shape.BoundBox.Center)
        d = target_c - hc_c_global
        d_inplane = d - n.multiply(d.dot(n))
        self.fusedArrays.Placement.Base = self.fusedArrays.Placement.Base + d_inplane

        doc.recompute()
        
    def supportShape(self, src_obj, subname):
        """
        Return the exact Face referenced by `subname` from `src_obj.Shape`,
        tolerating odd formats (e.g. ('Face3',), 'Face', etc.).
        """
        shp = src_obj.Shape

        # Normalize subname to a simple string like "FaceN"
        if isinstance(subname, (tuple, list)) and subname:
            subname = subname[0]

        # 1) Try direct lookup (best case)
        try:
            return shp.getElement(subname)
        except Exception:
            pass

        # 2) Parse trailing digits and index the Faces list
        try:
            import re
            m = re.search(r'(\d+)$', str(subname))
            if m:
                i = int(m.group(1)) - 1
                if 0 <= i < len(shp.Faces):
                    return shp.Faces[i]
        except Exception:
            pass

        # 3) Fallback: first face
        return shp.Faces[0] if shp.Faces else None

        
    def createShapeArray(self):
        doc = App.ActiveDocument

        # ---- Defer recomputes until the end
        had_autorc = getattr(doc, "AutoRecompute", True)
        if hasattr(doc, "AutoRecompute"):
            doc.AutoRecompute = False
        try:
            # 1) Hex profile driven by user sheet
            hexagon = doc.addObject("Part::RegularPolygon", "HoneycombHexagon")
            hexagon.Polygon = 6
            hexagon.setExpression('Circumradius', f'{userSheetLabel}.radius')

            # 2) One extrude, reused via links
            hex_extrude = doc.addObject('Part::Extrusion', 'ExtrudedHexagon')
            hex_extrude.Base = hexagon
            hex_extrude.Solid = True
            hex_extrude.setExpression('LengthFwd',        f'{userSheetLabel}.height')
            hex_extrude.setExpression('Placement.Base.x', f'{autoGeneratedLabel}.tweakX')
            hex_extrude.setExpression('Placement.Base.y', f'{autoGeneratedLabel}.tweakY')

            # 3) Two ortho arrays as *links* (memory-friendly)
            row1 = Draft.make_ortho_array(
                hex_extrude,
                v_x=App.Vector(1, 0, 0),
                v_y=App.Vector(0, 1, 0),
                n_x=1, n_y=1, use_link=True)

            row2 = Draft.make_ortho_array(
                hex_extrude,
                v_x=App.Vector(1, 0, 0),
                v_y=App.Vector(0, 1, 0),
                n_x=1, n_y=1, use_link=True)

            # Position at ZMin of the support face
            zmin = self.offset2D.Shape.BoundBox.ZMin
            row1.Placement.Base.z = zmin # type: ignore
            row2.Placement.Base.z = zmin # type: ignore

            # Drive both arrays from the auto sheet
            row2.setExpression('Placement.Base.x', f'{autoGeneratedLabel}.array2XPos') # type: ignore
            row2.setExpression('Placement.Base.y', f'{autoGeneratedLabel}.array2YPos') # type: ignore
            for arr in (row1, row2):
                arr.setExpression('IntervalX.x', f'{autoGeneratedLabel}.xInterval') # type: ignore
                arr.setExpression('IntervalY.y', f'{autoGeneratedLabel}.yInterval') # type: ignore
                arr.setExpression('NumberX',     f'{autoGeneratedLabel}.countX') # type: ignore
                arr.setExpression('NumberY',     f'{autoGeneratedLabel}.countY') # type: ignore

            # 4) Use a Compound instead of a MultiFuse (faster, enough for cutting)
            compound = doc.addObject("Part::Compound", "HoneycombCompound")
            compound.Links = [row1, row2]  # accepts arrays/links directly

            # Keep sources hidden; avoid GUI churn mid-build
            hexagon.ViewObject.Visibility = False
            row1.ViewObject.Visibility = False # type: ignore
            row2.ViewObject.Visibility = False # type: ignore

        finally:
            if hasattr(doc, "AutoRecompute"):
                doc.AutoRecompute = had_autorc
            doc.recompute()  # one-shot recompute

        # Store and hand back the single tool we’ll cut with
        self.fusedArrays = compound
        return compound
    
    
    @staticmethod
    def extrude(shape, length):
        # kept here in case you still want a local helper
        extruded = App.ActiveDocument.addObject('Part::Extrusion', 'Extruded')
        extruded.Base = shape
        extruded.DirMode = "Normal"
        extruded.LengthFwd = length if length > 0 else 0
        extruded.LengthRev = -length if length < 0 else 0
        extruded.Solid = True
        return extruded


class Folders:
    def __init__(self):
        pass

    @staticmethod
    def create(
        container_name: str = "Honeycomb",
        object_names = ("EditMe", "Offset2D", "Extruded", "Fused_Arrays"),
        body_name: str = "Body",
        binder_name: str = "Binder",
        use_part: bool = False,
        include_binder_link: bool = True,
    ):
        """
        Create (or reuse) a top-level container and place the generated objects inside it.
        - If use_part is True, an App::Part is created so placement is unified.
        - The Binder stays inside the Body; we optionally show it via an App::Link.
        - Idempotent: won’t re-add already grouped objects or duplicate the link.
        Returns: (container, binder_link or None)
        """
        doc = App.ActiveDocument
        if doc is None:
            raise RuntimeError("No active document.")

        # Pause recompute while we shuffle the tree
        had_autorecompute = getattr(doc, "AutoRecompute", True)
        if hasattr(doc, "AutoRecompute"):
            doc.AutoRecompute = False

        try:
            # 1) Create or reuse the container
            existing = doc.getObject(container_name)
            if existing and (existing.TypeId in ("App::DocumentObjectGroup", "App::Part")):
                container = existing
            else:
                # If a different object with that name exists, rename it to avoid conflict
                if existing and existing.TypeId not in ("App::DocumentObjectGroup", "App::Part"):
                    existing.Label = existing.Label + "_old"
                ctype = "App::Part" if use_part else "App::DocumentObjectGroup"
                container = doc.addObject(ctype, container_name)
                container.Label = container_name

            # 2) Optionally place the Body inside the Part (not the Group)
            body = doc.getObject(body_name)
            if use_part and body and body not in getattr(container, "Group", []):
                container.addObject(body)

            # Helper: add an object if it exists and isn’t already inside
            def _safe_add(obj):
                if not obj:
                    return
                if obj is container:
                    return
                current_group = getattr(container, "Group", [])
                if obj not in current_group:
                    container.addObject(obj)

            # 3) Add requested objects (skip Body if already handled)
            for name in object_names:
                obj = doc.getObject(name)
                if use_part and obj is body:
                    continue
                _safe_add(obj)

            # 4) Optionally expose the Binder via an App::Link (don’t move it)
            binder_link = None
            binder = doc.getObject(binder_name)
            if include_binder_link and binder:
                link_name = f"{binder_name}_Link"
                binder_link = doc.getObject(link_name)
                if binder_link is None:
                    binder_link = doc.addObject("App::Link", link_name)
                # Only update if it’s not already linked or links elsewhere
                if getattr(binder_link, "LinkedObject", None) is not binder:
                    binder_link.LinkedObject = binder
                _safe_add(binder_link)

            doc.recompute()
            return container, binder_link

        finally:
            if hasattr(doc, "AutoRecompute"):
                doc.AutoRecompute = had_autorecompute
            doc.recompute()


class Plane():
    def __init__(self):
        pass
    
    def createShapeBinder(self):
        sel_ex = Gui.Selection.getSelectionEx()
        if not sel_ex or not sel_ex[0].SubElementNames:
            raise Exception("Error: Select a face to create the honeycomb grid on.")

        self.doc = App.ActiveDocument
        sel = sel_ex[0]
        src_obj = sel.Object
        subname = sel.SubElementNames[0]

        def findBody(o):
            visited = set()
            queue = list(getattr(o, "InList", []))
            while queue:
                p = queue.pop(0)
                if p in visited:
                    continue
                visited.add(p)
                if getattr(p, "TypeId", "") == "PartDesign::Body":
                    return p
                # keep walking upward
                queue.extend(getattr(p, "InList", []))
            return None

        body = findBody(src_obj)
        self.body = body

        if body:
            binder = body.newObject('PartDesign::SubShapeBinder', 'Binder')
        else:
            binder = self.doc.addObject('PartDesign::SubShapeBinder', 'Binder')

        binder.Support = [(src_obj, subname)]
        binder.ViewObject.Visibility = False

        self.doc.recompute()
        return binder


    def createOffset2D(self, subShapeBinder):
        offset2D = App.activeDocument().addObject('Part::Offset2D', 'Offset2D')
        offset2D.Source = subShapeBinder
        offset2D.setExpression('Value', f'{userSheetLabel}.planeOffset')
        App.activeDocument().recompute()
        offset2D.ViewObject.Visibility = False
        return offset2D


    def extrude(self, shape, length = None, spreadsheet = None):
        print(type(spreadsheet))

        extrusion = App.ActiveDocument.addObject('Part::Extrusion', 'Extruded')
        extrusion.Base = shape
        extrusion.DirMode = "Normal"
        extrusion.Solid = True

        if length:
            L = float(length) if hasattr(length, 'Value') else float(length)
            extrusion.LengthFwd = L if L > 0 else 0
            extrusion.LengthRev = -L if L < 0 else 0
            return

        
        length = float(spreadsheet.height) # type: ignore
        sheet_label = spreadsheet.Name  # type: ignore
        expr_mm = f"({sheet_label}.height * 1 mm)"
        extrusion.setExpression('LengthFwd', f"max({expr_mm}, 0 mm)")
        extrusion.setExpression('LengthRev', f"max(-{expr_mm}, 0 mm)")
        return extrusion


    @staticmethod
    def alignShapeFace(obj1, faceIndex1, obj2, faceIndex2):
        import math
        face1 = obj1.Shape.Faces[faceIndex1]
        face2 = obj2.Shape.Faces[faceIndex2]

        normal1 = face1.normalAt(0.5, 0.5)
        normal2 = face2.normalAt(0.5, 0.5)
        rotation_axis = normal1.cross(normal2)
        if rotation_axis.Length == 0:
            rotation_axis = App.Vector(1, 0, 0)
        rotation_angle = normal1.getAngle(normal2)
        rotation = App.Rotation(rotation_axis, math.degrees(rotation_angle))
        obj1.Placement.Rotation = rotation.multiply(obj1.Placement.Rotation)
        App.ActiveDocument.recompute()

        center1 = face1.CenterOfMass
        center2 = face2.CenterOfMass
        translation = center2 - center1
        obj1.Placement.Base += translation
        App.ActiveDocument.recompute()

def delete_after_delay(objs, delay_ms=10000):
    """Delete the given objects after delay_ms milliseconds."""
    def _delete():
        doc = App.ActiveDocument
        for obj in objs:
            try:
                if obj and obj in doc.Objects:
                    doc.removeObject(obj.Name)
            except Exception as e:
                print(f"Could not delete {obj.Name}: {e}")
        doc.recompute()
    QtCore.QTimer.singleShot(delay_ms, _delete)

def main():
    # 1) Build user spreadsheet and binder
    sheet = SpreadSheet()
    userSpreadsheet = sheet.userSpreadSheet()

    plane = Plane()
    binder = plane.createShapeBinder()

    # 2) Offsets and extrusions
    offset2D_a = plane.createOffset2D(binder)
    offset2D_b = plane.createOffset2D(binder)
    extrusion_a = plane.extrude(offset2D_a, spreadsheet=userSpreadsheet)
    extrusion_b = plane.extrude(offset2D_b, spreadsheet=userSpreadsheet)

    # 3) Auto sheet + hex pattern
    autoGeneratedSpreadsheet = sheet.computingSpreadSheet(offset2D=offset2D_a)
    hexagons = ShapePattern(userSheet=userSpreadsheet,
                            autoGeneratedSheet=autoGeneratedSpreadsheet,
                            offset2D=offset2D_a,
                            type='hexagons')

    fused = hexagons.createShapeArray()
    #hexagons.alignShapes()

    # Expose arrays so we can delete them too
    row1, row2 = fused.Links
    compound = fused

    doc = plane.doc

    cutA = doc.addObject('Part::Cut', 'Cut_OffsetA_minus_Hexagons')
    cutA.Base = extrusion_a
    cutA.Tool = fused

    cutB = doc.addObject('Part::Cut', 'Cut_OffsetB_minus_Body')
    cutB.Base = plane.body
    cutB.Tool = extrusion_b

    doc.recompute()
    Gui.SendMsgToActiveView("ViewFit")

    """
    # --- cleanup after 10 sec ---
    delete_after_delay(
        [offset2D_a, offset2D_b,
         extrusion_a, extrusion_b,
         row1, row2, compound,
         cutA, cutB],
        delay_ms=20000
    )
    """

if __name__ == "__main__":
    main()
