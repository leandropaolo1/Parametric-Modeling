import ProfileLib.RegularPolygon
import DraftTools
import Sketcher
import FreeCAD as App
import Draft
import math
import Part
import GuiDocument
import FreeCADGui as Gui


hexSeparation       = .2
hexExtrusion        = 5
hexRadius           = 2
planeOffset         = -3
userSheetLabel      = "EditMe"
autoGeneratedLabel  = "AutoGenerated"




class SpreadSheet:
    def __init__(self):
        
        self.hexSeparation = hexSeparation
        self.hexExtrusion  = hexExtrusion
        self.hexRadius     = hexRadius
        self.planeOffset   = planeOffset
        self.name       = userSheetLabel
        self.aliases    = {}             # last aliases used (cell map)

    def _create_or_get_sheet(self, label: str):
        """Create or fetch a Spreadsheet::Sheet by label and prime self.set & self.sheet."""
        doc = App.ActiveDocument
        if not doc:
            raise RuntimeError("No active FreeCAD document.")
        sheet = doc.getObject(label)
        if sheet is None:
            sheet = doc.addObject("Spreadsheet::Sheet", label)
        sheet.setColumnWidth('A', 100)
        self.set   = sheet.set
        self.sheet = sheet
        self.name  = label
        return sheet

    def _write_aliases(self, aliases: dict):
        """Register aliases on the current sheet."""
        if not self.sheet:
            raise RuntimeError("Sheet not initialized.")
        for alias_name, cell in aliases.items():
            self.sheet.setAlias(cell, alias_name)
        self.aliases = aliases

    def userSpreadSheet(self):
        sheet = self._create_or_get_sheet(userSheetLabel)
        setc  = self.set

        aliases = {
            'radius':      'B2',
            'separation':  'B3',
            'height':      'B6',
            'planeOffset': 'B7',
        }
        
        self._write_aliases(aliases)

        setc('A1', 'User Variables')

        setc('A2', 'Hexagon Radius:');     setc(aliases['radius'],      str(self.hexRadius))
        setc('A3', 'Hexagon Separation:'); setc(aliases['separation'],  str(self.hexSeparation))
        setc('A6', 'Grid Height:');        setc(aliases['height'],      str(self.hexExtrusion))
        setc('A7', 'Plane Offset:');       setc(aliases['planeOffset'], str(planeOffset))

        App.ActiveDocument.recompute()
        return sheet

    def computingSpreadSheet(self, offset2D):
        sheet = self._create_or_get_sheet(autoGeneratedLabel)
        setc  = self.set

        aliases = {
            'radius':      'B2',
            'separation':  'B3',
            'height':      'B6',
            'planeOffset': 'B7',

            'width':       'B4',
            'length':      'B5',
            'tweakX':      'B8',
            'tweakY':      'B9',
            'tweakZ':      'B10',

            'xInterval':   'E2',
            'yInterval':   'E3',
            'firstX':      'E4',
            'firstY':      'E5',
            'countX':      'E6',
            'countY':      'E7',
            'array2XPos':  'E8',
            'array2YPos':  'E9',
        }
        
        self._write_aliases(aliases)

        setc('A1', 'Auto-Generated Variables')
        setc('D1', 'Calculated Values')
        setc('A2', 'Hexagon Radius:');     setc(aliases['radius'],     str(self.hexRadius))
        setc('A3', 'Hexagon Separation:'); setc(aliases['separation'], str(self.hexSeparation))
        setc('A6', 'Grid Height:');        setc(aliases['height'],     str(self.hexExtrusion))

        bbox             = offset2D.Shape.BoundBox
        maxOffsetLength  = bbox.XMax - bbox.XMin
        maxOffsetWidth   = bbox.YMax - bbox.YMin
        offset2DZMin     = bbox.ZMin

        setc('A4',  'Grid Width:');   setc(aliases['width'],   str(maxOffsetWidth))
        setc('A5',  'Grid Length:');  setc(aliases['length'],  str(maxOffsetLength))
        setc('A8',  'Tweak X:');      setc(aliases['tweakX'],  str(bbox.XMin))
        setc('A9',  'Tweak Y:');      setc(aliases['tweakY'],  str(bbox.YMin))
        setc('A10', 'Tweak Z:');      setc(aliases['tweakZ'],  str(offset2DZMin))

        setc('D2', 'X Interval:');   setc(aliases['xInterval'],  '=2*sin(60 deg)*(B2*2 + (B3 - 0.267949*B2))')
        setc('D3', 'Y Interval:');   setc(aliases['yInterval'],  '=2*B2 + (B3 - 0.267949*B2)')
        setc('D4', 'First X:');      setc(aliases['firstX'],     '=B2')
        setc('D5', 'First Y:');      setc(aliases['firstY'],     '=B2')
        setc('D6', 'Count X:');      setc(aliases['countX'],     '=round(B5 / E2) + 2')
        setc('D7', 'Count Y:');      setc(aliases['countY'],     '=round(B4 / E3) + 2')
        setc('D8', 'Array2 XPos:');  setc(aliases['array2XPos'], '=sin(60 deg)*(B2*2 + B3 - 0.267949*B2)')
        setc('D9', 'Array2 YPos:');  setc(aliases['array2YPos'], '=E3/2')

        App.ActiveDocument.recompute()
        return sheet

    def write(self):
        """Kept for compatibility; recompute and return the active sheet."""
        if not self.sheet:
            raise RuntimeError("No sheet to write to. Call userSheet() or autoGeneratedLabel() first.")
        App.ActiveDocument.recompute()
        return self.sheet


class ShapePattern():
    def __init__(self, userSheet, autoGeneratedSheet):
        pass

    def alignShapes(fusedArrays, extrudedOffset):
        alignShapeFace(fusedArrays, 7, extrudedOffset, 0)


    def createShapeArray(
            offset2DZPos: float,
            selMidPoint: App.Vector,
            xInterval: float,
            yInterval: float,
            countX: int,
            countY: int,
            hexRadius: float,
            hexSeparation: float,
            hexExtrusion: float):

        doc = App.ActiveDocument

        honeycombHexagon = doc.addObject("Part::RegularPolygon", "HoneycombHexagon")
        honeycombHexagon.Polygon = 6
        honeycombHexagon.setExpression('Circumradius', f'{userSheetLabel}.radius')
        doc.recompute()

        extrudedHexagonObject = doc.addObject('Part::Extrusion', 'ExtrudedHexagon')
        extrudedHexagonObject.Base = honeycombHexagon
        extrudedHexagonObject.setExpression('LengthFwd', f'{userSheetLabel}.height')
        extrudedHexagonObject.Solid = True
        extrudedHexagonObject.setExpression('Placement.Base.x', f'{autoGeneratedLabel}.tweakX')
        extrudedHexagonObject.setExpression('Placement.Base.y', f'{autoGeneratedLabel}.tweakY')
        doc.recompute()

        xvector = App.Vector(xInterval, 0, 0)
        yvector = App.Vector(0, yInterval, 0)

        row1Array = Draft.make_ortho_array(
            extrudedHexagonObject, v_x=xvector, v_y=yvector,
            n_x=countX, n_y=countY, use_link=False)

        row2Array = Draft.make_ortho_array(
            extrudedHexagonObject, v_x=xvector, v_y=yvector,
            n_x=countX, n_y=countY, use_link=False)

        doc.recompute()

        row1Array.Placement.Base.z = offset2DZPos # type: ignore
        row2Array.Placement = App.Placement( # type: ignore
            App.Vector(math.sin(math.radians(60))*(hexRadius*2 + (hexSeparation - 0.267949)),
                    yInterval,
                    offset2DZPos),
            App.Rotation(0, 0, 0), App.Vector(0, 0, 0))

        # Spreadsheet-driven params
        row2Array.setExpression('Placement.Base.x', f'{autoGeneratedLabel}.array2XPos') # type: ignore
        row2Array.setExpression('Placement.Base.y', f'{autoGeneratedLabel}.array2YPos') # type: ignore
        for arr in (row1Array, row2Array):
            arr.setExpression('IntervalX.x', f'{autoGeneratedLabel}.xInterval') # type: ignore
            arr.setExpression('IntervalY.y', f'{autoGeneratedLabel}.yInterval') # type: ignore
            arr.setExpression('NumberX',     f'{autoGeneratedLabel}.countX') # type: ignore
            arr.setExpression('NumberY',     f'{autoGeneratedLabel}.countY') # type: ignore

        # 5) Visuals
        row1Array.ViewObject.ShapeColor = (255, 16, 240)  # type: ignore
        row2Array.ViewObject.ShapeColor = (191, 255, 0)   # type: ignore

        # 6) Fuse + center on selection
        fusedArrys = doc.addObject("Part::MultiFuse", "Fused_Arrays")
        fusedArrys.Shapes = [row1Array, row2Array]
        row1Array.Visibility = False  # type: ignore
        row2Array.Visibility = False # type: ignore
        doc.recompute()

        arraysMidPoint = fusedArrys.Shape.BoundBox.Center
        fusedArrys.Placement.Base = App.Vector(
            selMidPoint.x - arraysMidPoint.x,
            selMidPoint.y - arraysMidPoint.y,
            fusedArrys.Placement.Base.z)

        Gui.SendMsgToActiveView("ViewFit")

        # 7) Clean up the source 2D profile AFTER everything is stable
        honeycombHexagon.ViewObject.Visibility = False
        doc.recompute()

        return fusedArrys


    def extrude(shape, length):
        extruded = App.ActiveDocument.addObject('Part::Extrusion', 'Extruded')
        extruded.Base = shape
        extruded.DirMode = "Normal"
        extruded.LengthFwd = length if length > 0 else 0
        extruded.LengthRev = -length if length < 0 else 0
        extruded.Solid = True
        App.ActiveDocument.recompute()
        return extruded


class Folders():
    def __init__(self):
        pass

    def create(
        container_name: str = "Honeycomb",
        object_names = ("EditMe", "Offset2D", "Extruded", "Fused_Arrays"),
        body_name: str = "Body",
        binder_name: str = "Binder",
        use_part: bool = False,
        include_binder_link: bool = True):

        doc = App.ActiveDocument
        if doc is None:
            raise RuntimeError("No active document.")

        # Avoid repetitive recomputes while we reorganize
        old_auto = getattr(doc, "AutoRecompute", True)
        try:
            if hasattr(doc, "AutoRecompute"):
                doc.AutoRecompute = False

            # 1) Create container
            container_type = 'App::Part' if use_part else 'App::DocumentObjectGroup'
            container = doc.addObject(container_type, f"{container_name}")
            container.Label = container_name

            # 2) If using App::Part, put the Body inside so everything moves together
            binder_link = None
            body = doc.getObject(body_name)
            if use_part and body:
                container.addObject(body)

            # 3) Add requested objects (skip Binder—keep it in the Body)
            for name in object_names:
                obj = doc.getObject(name)
                if obj is None:
                    continue
                # Don’t try to move Body again
                if use_part and obj is body:
                    continue
                container.addObject(obj)

            # 4) Optionally show the Binder in the container via a Link (safer than moving it)
            binder = doc.getObject(binder_name)
            if include_binder_link and binder:
                # Reuse an existing link if we already made one
                link_name = f"{binder_name}_Link"
                binder_link = doc.getObject(link_name)
                if binder_link is None:
                    binder_link = doc.addObject('App::Link', link_name)
                binder_link.LinkedObject = binder
                container.addObject(binder_link)

            doc.recompute()
            return container, binder_link

        finally:
            if hasattr(doc, "AutoRecompute"):
                doc.AutoRecompute = old_auto
            doc.recompute()


class Plane():
    def __init__(self):
        pass
    
    def createShapeBinder(self):
        selected_items = Gui.Selection.getSelectionEx()
        if not selected_items or not selected_items[0].SubObjects:
            raise Exception("Error: Select a face to create the honeycomb grid on.")


        selected_item = selected_items[0]
        doc = App.ActiveDocument
        body = doc.getObject('Body')
        subShapeBinder = body.newObject('PartDesign::SubShapeBinder', 'Binder')
        subShapeBinder.Support = [
            (selected_item.Object, selected_item.SubElementNames[0])]
        doc.recompute()
        subShapeBinder.ViewObject.Visibility = True
        
        return subShapeBinder


    def createOffset2D(self, subShapeBinder):
        offset2D = App.activeDocument().addObject('Part::Offset2D', 'Offset2D')
        offset2D.Source = subShapeBinder
        offset2D.setExpression('Value', f'{userSheetLabel}.planeOffset')
        App.activeDocument().recompute()
        return offset2D


    def extrude(self, shape, length = None, spreadsheet = None):
        print(type(spreadsheet))
        """
        length:
        - number / Quantity  -> extrudes forward if > 0, reverse if < 0
        - str (expression)   -> evaluated by FreeCAD; forward = max(expr, 0 mm),
                                reverse = max(-expr, 0 mm)
        """
        extruded = App.ActiveDocument.addObject('Part::Extrusion', 'Extruded')
        extruded.Base = shape
        extruded.DirMode = "Normal"
        extruded.Solid = True

        if length:
            L = float(length) if hasattr(length, 'Value') else float(length)
            extruded.LengthFwd = L if L > 0 else 0
            extruded.LengthRev = -L if L < 0 else 0
            return

        
        length = float(spreadsheet.height) # type: ignore
        sheet_label = spreadsheet.Name  # type: ignore
        expr_mm = f"({sheet_label}.height * 1 mm)"
        extruded.setExpression('LengthFwd', f"max({expr_mm}, 0 mm)")
        extruded.setExpression('LengthRev', f"max(-{expr_mm}, 0 mm)")


    @staticmethod
    def alignShapeFace(obj1, faceIndex1, obj2, faceIndex2):
        import math
        face1 = obj1.Shape.Faces[faceIndex1]
        face2 = obj2.Shape.Faces[faceIndex2]

        normal1 = face1.normalAt(0.5, 0.5)
        normal2 = face2.normalAt(0.5, 0.5)
        rotation_axis = normal1.cross(normal2)
        if rotation_axis.Length == 0:
            rotation_axis = App.Vector(1, 0, 0)
        rotation_angle = normal1.getAngle(normal2)
        rotation = App.Rotation(rotation_axis, math.degrees(rotation_angle))
        obj1.Placement.Rotation = rotation.multiply(obj1.Placement.Rotation)
        App.ActiveDocument.recompute()

        center1 = face1.CenterOfMass
        center2 = face2.CenterOfMass
        translation = center2 - center1
        obj1.Placement.Base += translation
        App.ActiveDocument.recompute()


def main():
    sheet = SpreadSheet()
    userSpreadsheet = sheet.userSpreadSheet()
    subShapeBinder = Plane()
    
    offset2D = subShapeBinder.createOffset2D(subShapeBinder.createShapeBinder())
    subShapeBinder.extrude(offset2D, spreadsheet=userSpreadsheet)
    autoGeneratedSpreadsheet = sheet.computingSpreadSheet(offset2D=offset2D)

    #sheet.autoGeneratedSheet(offset2D, planeOffset_value=planeOffset)
    #offset2D.setExpression('Value', f'{autoGeneratedLabel}.planeOffset')



if __name__ == "__main__":
    main()