import math

import Draft
import FreeCAD as App
import FreeCADGui as Gui
from BOPTools import BOPFeatures

hexSeparation = 1
hexExtrusion = -2
hexRadius = 4
planeOffset = -3
userSheetLabel = "EditMe"
autoGeneratedLabel = "AutoGenerated"


class SpreadSheet:
    def __init__(self):
        self.hexSeparation = hexSeparation
        self.hexExtrusion = hexExtrusion
        self.hexRadius = hexRadius
        self.planeOffset = planeOffset
        self.name = userSheetLabel
        self.aliases = {}  # last aliases used (cell map)

    def create(self, label: str):
        """Create or fetch a Spreadsheet::Sheet by label and prime self.set & self.sheet."""
        doc = App.ActiveDocument
        if not doc:
            raise RuntimeError("No active FreeCAD document.")
        sheet = doc.getObject(label)
        if sheet is None:
            sheet = doc.addObject("Spreadsheet::Sheet", label)
        sheet.setColumnWidth("A", 150)
        self.set = sheet.set
        self.sheet = sheet
        self.name = label
        return sheet

    def aliase(self, aliases: dict):
        """Register aliases on the current sheet."""
        if not self.sheet:
            raise RuntimeError("Sheet not initialized.")
        for alias_name, cell in aliases.items():
            self.sheet.setAlias(cell, alias_name)
        self.aliases = aliases

    def userSpreadSheet(self):
        sheet = self.create(userSheetLabel)
        setc = self.set

        aliases = {
            "radius": "B2",
            "separation": "B3",
            "height": "B6",
            "planeOffset": "B7",
        }

        self.aliase(aliases)

        setc("A1", "User Variables")
        setc("A2", "Hexagon Radius:")
        setc(aliases["radius"], str(self.hexRadius))
        setc("A3", "Hexagon Separation:")
        setc(aliases["separation"], str(self.hexSeparation))
        setc("A6", "Grid Height:")
        setc(aliases["height"], str(self.hexExtrusion))
        setc("A7", "Plane Offset:")
        setc(aliases["planeOffset"], str(planeOffset))

        App.ActiveDocument.recompute()
        return sheet

    def compute(self, offset2D):
        sheet = self.create(autoGeneratedLabel)
        setc = self.set

        aliases = {
            "radius": "B2",
            "separation": "B3",
            "height": "B6",
            "planeOffset": "B7",
            "width": "B4",
            "length": "B5",
            "tweakX": "B8",
            "tweakY": "B9",
            "tweakZ": "B10",
            "xInterval": "E2",
            "yInterval": "E3",
            "firstX": "E4",
            "firstY": "E5",
            "countX": "E6",
            "countY": "E7",
            "array2XPos": "E8",
            "array2YPos": "E9",
        }

        self.aliase(aliases)

        setc("A1", "Auto-Generated Variables")
        setc("D1", "Calculated Values")
        setc("A2", "Hexagon Radius:")
        setc(aliases["radius"], f"={userSheetLabel}.radius")
        setc("A3", "Hexagon Separation:")
        setc(aliases["separation"], f"={userSheetLabel}.separation")
        setc("A6", "Grid Height:")
        setc(aliases["height"], f"={userSheetLabel}.height")

        bbox = offset2D.Shape.BoundBox
        maxOffsetLength = bbox.XMax - bbox.XMin
        maxOffsetWidth = bbox.YMax - bbox.YMin
        offset2DZMin = bbox.ZMin

        setc("A4", "Grid Width:")
        setc(aliases["width"], str(maxOffsetWidth))
        setc("A5", "Grid Length:")
        setc(aliases["length"], str(maxOffsetLength))
        setc("A8", "Tweak X:")
        setc(aliases["tweakX"], str(bbox.XMin))
        setc("A9", "Tweak Y:")
        setc(aliases["tweakY"], str(bbox.YMin))
        setc("A10", "Tweak Z:")
        setc(aliases["tweakZ"], str(offset2DZMin))

        setc("D2", "X Interval:")
        setc(aliases["xInterval"], "=2*sin(60 deg)*(B2*2 + (B3 - 0.267949*B2))")
        setc("D3", "Y Interval:")
        setc(aliases["yInterval"], "=2*B2 + (B3 - 0.267949*B2)")
        setc("D4", "First X:")
        setc(aliases["firstX"], "=B2")
        setc("D5", "First Y:")
        setc(aliases["firstY"], "=B2")
        setc("D6", "Count X:")
        setc(aliases["countX"], "=round(B5 / E2) + 2")
        setc("D7", "Count Y:")
        setc(aliases["countY"], "=round(B4 / E3) + 2")
        setc("D8", "Array2 XPos:")
        setc(aliases["array2XPos"], "=sin(60 deg)*(B2*2 + B3 - 0.267949*B2)")
        setc("D9", "Array2 YPos:")
        setc(aliases["array2YPos"], "=E3/2")

        App.ActiveDocument.recompute()
        return sheet

    def write(self):
        """Kept for compatibility; recompute and return the active sheet."""
        if not self.sheet:
            raise RuntimeError(
                "No sheet to write to. Call userSheet() or autoGeneratedLabel() first."
            )
        App.ActiveDocument.recompute()
        return self.sheet


class HexagonalPattern:
    def __init__(self, userSheet, autoGeneratedSheet, offset2D, type):
        self.autoGeneratedSheet = autoGeneratedSheet
        self.userSheet = userSheet
        self.offset2D = offset2D
        self.type = type or "hexagons"  # honor the arg, default if None
        self.fusedArrays = None

    def alignShapes(self, extrudedOffset):
        # use the helper correctly (it's a @staticmethod on Plane)
        Plane.alignShapeFace(self.fusedArrays, 7, extrudedOffset, 0)

    def createShapeArray(self):
        doc = App.ActiveDocument

        had_autorc = getattr(doc, "AutoRecompute", True)
        if hasattr(doc, "AutoRecompute"):
            doc.AutoRecompute = False
        try:
            hexagon = doc.addObject("Part::RegularPolygon", "HoneycombHexagon")
            hexagon.Polygon = 6
            hexagon.setExpression("Circumradius", f"{userSheetLabel}.radius")

            # 2) One extrude, reused via links
            hex_extrude = doc.addObject("Part::Extrusion", "ExtrudedHexagon")
            hex_extrude.Base = hexagon
            hex_extrude.Solid = True
            hex_extrude.setExpression("LengthFwd", f"{userSheetLabel}.height")
            hex_extrude.setExpression(
                "Placement.Base.x", f"{autoGeneratedLabel}.tweakX"
            )
            hex_extrude.setExpression(
                "Placement.Base.y", f"{autoGeneratedLabel}.tweakY"
            )

            row1 = Draft.make_ortho_array(
                hex_extrude,
                v_x=App.Vector(1, 0, 0),
                v_y=App.Vector(0, 1, 0),
                n_x=1,
                n_y=1,
                use_link=True,
            )  # ← use_link!

            row2 = Draft.make_ortho_array(
                hex_extrude,
                v_x=App.Vector(1, 0, 0),
                v_y=App.Vector(0, 1, 0),
                n_x=1,
                n_y=1,
                use_link=True,
            )  # ← use_link!

            # Position at ZMin of the support face
            zmin = self.offset2D.Shape.BoundBox.ZMin
            row1.Placement.Base.z = zmin  # type: ignore
            row2.Placement.Base.z = zmin  # type: ignore

            # Drive both arrays from the auto sheet
            row2.setExpression("Placement.Base.x", f"{autoGeneratedLabel}.array2XPos")  # type: ignore
            row2.setExpression("Placement.Base.y", f"{autoGeneratedLabel}.array2YPos")  # type: ignore
            for arr in (row1, row2):
                arr.setExpression("IntervalX.x", f"{autoGeneratedLabel}.xInterval")  # type: ignore
                arr.setExpression("IntervalY.y", f"{autoGeneratedLabel}.yInterval")  # type: ignore
                arr.setExpression("NumberX", f"{autoGeneratedLabel}.countX")  # type: ignore
                arr.setExpression("NumberY", f"{autoGeneratedLabel}.countY")  # type: ignore

            # 4) Use a Compound instead of a MultiFuse (faster, enough for cutting)
            compound = doc.addObject("Part::Compound", "HoneycombCompound")
            compound.Links = [row1, row2]  # accepts arrays/links directly

            # Keep sources hidden; avoid GUI churn mid-build
            hexagon.ViewObject.Visibility = False
            row1.ViewObject.Visibility = False  # type: ignore
            row2.ViewObject.Visibility = False  # type: ignore

        finally:
            if hasattr(doc, "AutoRecompute"):
                doc.AutoRecompute = had_autorc
            doc.recompute()  # one-shot recompute

        # Store and hand back the single tool we’ll cut with
        self.fusedArrays = compound
        return compound

    @staticmethod
    def extrude(shape, length):
        # kept here in case you still want a local helper
        extruded = App.ActiveDocument.addObject("Part::Extrusion", "Extruded")
        extruded.Base = shape
        extruded.DirMode = "Normal"
        extruded.LengthFwd = length if length > 0 else 0
        extruded.LengthRev = -length if length < 0 else 0
        extruded.Solid = True
        return extruded


class Folders:
    def __init__(self):
        pass

    @staticmethod
    def create(
        container_name: str = "Honeycomb",
        object_names=("EditMe", "Offset2D", "Extruded", "Fused_Arrays"),
        body_name: str = "Body",
        binder_name: str = "Binder",
        use_part: bool = False,
        include_binder_link: bool = True,
    ):
        """
        Create (or reuse) a top-level container and place the generated objects inside it.
        - If use_part is True, an App::Part is created so placement is unified.
        - The Binder stays inside the Body; we optionally show it via an App::Link.
        - Idempotent: won’t re-add already grouped objects or duplicate the link.
        Returns: (container, binder_link or None)
        """
        doc = App.ActiveDocument
        if doc is None:
            raise RuntimeError("No active document.")

        # Pause recompute while we shuffle the tree
        had_autorecompute = getattr(doc, "AutoRecompute", True)
        if hasattr(doc, "AutoRecompute"):
            doc.AutoRecompute = False

        try:
            # 1) Create or reuse the container
            existing = doc.getObject(container_name)
            if existing and (
                existing.TypeId in ("App::DocumentObjectGroup", "App::Part")
            ):
                container = existing
            else:
                # If a different object with that name exists, rename it to avoid conflict
                if existing and existing.TypeId not in (
                    "App::DocumentObjectGroup",
                    "App::Part",
                ):
                    existing.Label = existing.Label + "_old"
                ctype = "App::Part" if use_part else "App::DocumentObjectGroup"
                container = doc.addObject(ctype, container_name)
                container.Label = container_name

            # 2) Optionally place the Body inside the Part (not the Group)
            body = doc.getObject(body_name)
            if use_part and body and body not in getattr(container, "Group", []):
                container.addObject(body)

            # Helper: add an object if it exists and isn’t already inside
            def _safe_add(obj):
                if not obj:
                    return
                if obj is container:
                    return
                current_group = getattr(container, "Group", [])
                if obj not in current_group:
                    container.addObject(obj)

            # 3) Add requested objects (skip Body if already handled)
            for name in object_names:
                obj = doc.getObject(name)
                if use_part and obj is body:
                    continue
                _safe_add(obj)

            # 4) Optionally expose the Binder via an App::Link (don’t move it)
            binder_link = None
            binder = doc.getObject(binder_name)
            if include_binder_link and binder:
                link_name = f"{binder_name}_Link"
                binder_link = doc.getObject(link_name)
                if binder_link is None:
                    binder_link = doc.addObject("App::Link", link_name)
                # Only update if it’s not already linked or links elsewhere
                if getattr(binder_link, "LinkedObject", None) is not binder:
                    binder_link.LinkedObject = binder
                _safe_add(binder_link)

            doc.recompute()
            return container, binder_link

        finally:
            if hasattr(doc, "AutoRecompute"):
                doc.AutoRecompute = had_autorecompute
            doc.recompute()


class Plane:
    def __init__(self):
        pass

    def createShapeBinder(self):
        selected_items = Gui.Selection.getSelectionEx()
        if not selected_items or not selected_items[0].SubObjects:
            raise Exception("Error: Select a face to create the honeycomb grid on.")

        selected_item = selected_items[0]
        self.doc = App.ActiveDocument
        self.body = self.doc.getObject("Body")
        subShapeBinder = self.body.newObject("PartDesign::SubShapeBinder", "Binder")
        subShapeBinder.Support = [
            (selected_item.Object, selected_item.SubElementNames[0])
        ]
        self.doc.recompute()
        subShapeBinder.ViewObject.Visibility = False

        return subShapeBinder

    def createOffset2D(self, subShapeBinder):
        offset2D = App.activeDocument().addObject("Part::Offset2D", "Offset2D")
        offset2D.Source = subShapeBinder
        offset2D.setExpression("Value", f"{userSheetLabel}.planeOffset")
        App.activeDocument().recompute()
        offset2D.ViewObject.Visibility = False
        return offset2D

    def extrude(self, shape, length=None, spreadsheet=None):
        print(type(spreadsheet))

        extrusion = App.ActiveDocument.addObject("Part::Extrusion", "Extruded")
        extrusion.Base = shape
        extrusion.DirMode = "Normal"
        extrusion.Solid = True

        if length:
            L = float(length) if hasattr(length, "Value") else float(length)
            extrusion.LengthFwd = L if L > 0 else 0
            extrusion.LengthRev = -L if L < 0 else 0
            return

        length = float(spreadsheet.height)  # type: ignore
        sheet_label = spreadsheet.Name  # type: ignore
        expr_mm = f"({sheet_label}.height * 1 mm)"
        extrusion.setExpression("LengthFwd", f"max({expr_mm}, 0 mm)")
        extrusion.setExpression("LengthRev", f"max(-{expr_mm}, 0 mm)")
        return extrusion

    @staticmethod
    def alignShapeFace(obj1, faceIndex1, obj2, faceIndex2):
        import math

        face1 = obj1.Shape.Faces[faceIndex1]
        face2 = obj2.Shape.Faces[faceIndex2]

        normal1 = face1.normalAt(0.5, 0.5)
        normal2 = face2.normalAt(0.5, 0.5)
        rotation_axis = normal1.cross(normal2)
        if rotation_axis.Length == 0:
            rotation_axis = App.Vector(1, 0, 0)
        rotation_angle = normal1.getAngle(normal2)
        rotation = App.Rotation(rotation_axis, math.degrees(rotation_angle))
        obj1.Placement.Rotation = rotation.multiply(obj1.Placement.Rotation)
        App.ActiveDocument.recompute()

        center1 = face1.CenterOfMass
        center2 = face2.CenterOfMass
        translation = center2 - center1
        obj1.Placement.Base += translation
        App.ActiveDocument.recompute()


def main():
    # 1) Build the User sheet and create the working plane/binder
    sheet = SpreadSheet()
    userSpreadsheet = sheet.userSpreadSheet()

    plane = Plane()
    binder = plane.createShapeBinder()

    # 2) Create 2D offset and extrude it, driven by the User sheet height
    offset2D_a = plane.createOffset2D(binder)
    offset2D_b = plane.createOffset2D(binder)
    extrusion_a = plane.extrude(
        offset2D_a, spreadsheet=userSpreadsheet
    )  # creates object named "Extruded"
    extrusion_b = plane.extrude(offset2D_b, spreadsheet=userSpreadsheet)

    # 3) Build the Auto-Generated sheet off the offset geometry
    autoGeneratedSpreadsheet = sheet.compute(offset2D=offset2D_a)

    # Create the honeycomb arrays and align them to the base extrusion
    hexagons = HexagonalPattern(
        userSheet=userSpreadsheet,
        autoGeneratedSheet=autoGeneratedSpreadsheet,
        offset2D=offset2D_a,
        type="hexagons",
    )

    fused = hexagons.createShapeArray()

    doc = plane.doc

    # Find the Part (container) that owns plane.body
    part_container = None
    for parent in getattr(plane.body, "InList", []):
        if getattr(parent, "TypeId", "") == "App::Part":
            part_container = parent
            break

    # --- Cut_B: Extruded_b - Body, created INSIDE the same Part as Body
    # Ensure extrusion_b is in the same Part as Body (to avoid cross-scope links)
    if part_container:
        if extrusion_b not in getattr(part_container, "Group", []):
            part_container.addObject(extrusion_b)

    cutB = doc.addObject("Part::Cut", "Cut_OffsetB_minus_Body")
    cutB.Base = plane.body  # A - B
    cutB.Tool = extrusion_b
    if part_container:
        part_container.addObject(cutB)  # place the cut inside the Part

    # --- Cut_A: Extruded_a - Fused_Arrays (both are at document root, so keep the Cut at root too)
    cutA = doc.addObject("Part::Cut", "Cut_OffsetA_minus_Hexagons")
    cutA.Base = extrusion_a
    cutA.Tool = fused

    # Optional: hide sources
    # if extrusion_a: extrusion_a.ViewObject.Visibility = False
    # if extrusion_b: extrusion_b.ViewObject.Visibility = False

    doc.recompute()
    Gui.SendMsgToActiveView("ViewFit")


if __name__ == "__main__":
    main()
