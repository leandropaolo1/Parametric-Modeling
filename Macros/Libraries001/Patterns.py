import math

import Draft
import FreeCAD as App
import FreeCADGui as Gui
import numpy as np
from PySide import QtCore
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d.art3d import Poly3DCollection
from Libraries001.Transformation import Points

hexSeparation = 1
hexExtrusion = -2
hexRadius = 4
planeOffset = -3
userSheetLabel = "EditMe"
autoGeneratedLabel = "AutoGenerated"


class HexagonalPattern:
    def __init__(self, userSheet, autoGeneratedSheet, offset2D, type):
        self.autoGeneratedSheet = autoGeneratedSheet
        self.type = type or "hexagons"
        self.userSheet = userSheet
        self.offset2D = offset2D
        self.fusedArrays = None
        self.K = []

    def create(self):
        doc = App.ActiveDocument

        # ---- Defer recomputes until the end
        had_autorc = getattr(doc, "AutoRecompute", True)
        if hasattr(doc, "AutoRecompute"):
            doc.AutoRecompute = False
        try:
            # 1) Hex profile driven by user sheet
            hexagon = doc.addObject("Part::RegularPolygon", "HoneycombHexagon")
            hexagon.Polygon = 6
            hexagon.setExpression("Circumradius", f"{userSheetLabel}.radius")
                    # recompute to make shape usable
            doc.recompute()

            self.hexagon = np.array([[v.X, v.Y, v.Z] for v in hexagon.Shape.Vertexes])
            row1 = Draft.make_ortho_array(
                hexagon,
                v_x=App.Vector(1, 0, 0),
                v_y=App.Vector(0, 1, 0),
                n_x=1,
                n_y=1,
                use_link=True,
            )

            row2 = Draft.make_ortho_array(
                hexagon,
                v_x=App.Vector(1, 0, 0),
                v_y=App.Vector(0, 1, 0),
                n_x=1,
                n_y=1,
                use_link=True,
            )

            row2.setExpression("Placement.Base.x", f"{autoGeneratedLabel}.array2XPos")  # type: ignore
            row2.setExpression("Placement.Base.y", f"{autoGeneratedLabel}.array2YPos")  # type: ignore

            for arr in (row1, row2):
                arr.setExpression("IntervalX.x", f"{autoGeneratedLabel}.xInterval")  # type: ignore
                arr.setExpression("IntervalY.y", f"{autoGeneratedLabel}.yInterval")  # type: ignore
                arr.setExpression("NumberX", f"{autoGeneratedLabel}.countX")  # type: ignore
                arr.setExpression("NumberY", f"{autoGeneratedLabel}.countY")  # type: ignore

            # 4) Use a Compound instead of a MultiFuse (faster, enough for cutting)
            compound = doc.addObject("Part::Compound", "HoneycombCompound")
            compound.Links = [row1, row2]  # accepts arrays/links directly

            hexagon.ViewObject.Visibility = False
            row1.ViewObject.Visibility = False  # type: ignore
            row2.ViewObject.Visibility = False  # type: ignore

        finally:
            if hasattr(doc, "AutoRecompute"):
                doc.AutoRecompute = had_autorc
            doc.recompute()  # one-shot recompute

        self.fusedArrays = compound
        return compound

    def align(self, reference, target=None):
        if target is None:
            target = self.fusedArrays
        referencePlacement = reference.getGlobalPlacement()
        targetPlacement = target.getGlobalPlacement()

        referenceFace = reference.Shape.Faces[0]
        referenceWire = referenceFace.OuterWire
        referencePoints = np.array([
            [referencePlacement.multVec(v.Point).x,
            referencePlacement.multVec(v.Point).y,
            referencePlacement.multVec(v.Point).z]
            for v in referenceWire.Vertexes
        ])


        targetPoints = np.array([
            [targetPlacement.multVec(v.Point).x,
            targetPlacement.multVec(v.Point).y,
            targetPlacement.multVec(v.Point).z]
            for v in list(target.Shape.Vertexes)[:4]
        ])
        
        N = min(len(referencePoints), len(targetPoints))
        referencePoints = referencePoints[:N]
        targetPoints = targetPoints[:N]

        if len(referencePoints) != len(targetPoints):
            raise RuntimeError(
                f"Point count mismatch: reference={len(referencePoints)}, target={len(targetPoints)}"
            )

        referenceMean = referencePoints.mean(axis=0)
        targetMean = targetPoints.mean(axis=0)
        P = referencePoints - referenceMean
        Q = targetPoints - targetMean

        H = Q.T @ P
        U, S, Vt = np.linalg.svd(H)
        R = Vt.T @ U.T
        if np.linalg.det(R) < 0:
            Vt[-1, :] *= -1
            R = Vt.T @ U.T

        m = App.Matrix(
            R[0,0], R[0,1], R[0,2], 0,
            R[1,0], R[1,1], R[1,2], 0,
            R[2,0], R[2,1], R[2,2], 0,
            0,      0,      0,      1
        )
        rot = App.Rotation(m)

        targetVector = App.Vector(*targetMean)
        referenceVector = App.Vector(*referenceMean)
        translation = referenceVector - rot.multVec(targetVector)
        target.Placement = App.Placement(translation, rot)
        referenceCenter = reference.Shape.CenterOfGravity
        targetCenter = target.Shape.CenterOfGravity
        placement = target.Placement
        placement.Base = placement.Base.add(referenceCenter.sub(targetCenter))
        target.Placement = placement
        App.ActiveDocument.recompute()

        return target


    def extrude(self, length=None):
        extruded = App.ActiveDocument.addObject("Part::Extrusion", "Extruded")
        extruded.Base = self.fusedArrays
        extruded.DirMode = "Normal"
        extruded.Solid = True

        if length is None:
            # Bind directly to spreadsheet value (userSheetLabel.height)
            extruded.setExpression("LengthFwd", f"{self.userSheet.Label}.height")
            extruded.LengthRev = 0  # avoid conflict
        else:
            # Handle explicit numeric input
            extruded.LengthFwd = length if length > 0 else 0
            extruded.LengthRev = -length if length < 0 else 0

        return extruded

    @staticmethod
    def getGlobalRotation(plane):
        globalRotation = getattr(plane, "getGlobalPlacement", None)
        if callable(globalRotation):
            return globalRotation().Rotation  # type: ignore
        return plane.Placement.Rotation

    @staticmethod
    def getDeltaRotation(reference, target):
        baseRotation = App.Rotation(reference)
        baseRotation.invert()
        return baseRotation.multiply(target)


class VoroniPattern():
    def __init__(self, userSheet, autoGeneratedSheet, offset2D, type):
        self.autoGeneratedSheet = autoGeneratedSheet
        self.type = type or "hexagons"
        self.userSheet = userSheet
        self.offset2D = offset2D
        self.fusedArrays = None
        self.K = []

    def create(self):
        doc = App.ActiveDocument

        # ---- Defer recomputes until the end
        had_autorc = getattr(doc, "AutoRecompute", True)
        if hasattr(doc, "AutoRecompute"):
            doc.AutoRecompute = False
        try:
            # 1) Hex profile driven by user sheet
            hexagon = doc.addObject("Part::RegularPolygon", "HoneycombHexagon")
            hexagon.Polygon = 6
            hexagon.setExpression("Circumradius", f"{userSheetLabel}.radius")
                    # recompute to make shape usable
            doc.recompute()

            self.hexagon = np.array([[v.X, v.Y, v.Z] for v in hexagon.Shape.Vertexes])
            row1 = Draft.make_ortho_array(
                hexagon,
                v_x=App.Vector(1, 0, 0),
                v_y=App.Vector(0, 1, 0),
                n_x=1,
                n_y=1,
                use_link=True,
            )

            row2 = Draft.make_ortho_array(
                hexagon,
                v_x=App.Vector(1, 0, 0),
                v_y=App.Vector(0, 1, 0),
                n_x=1,
                n_y=1,
                use_link=True,
            )

            row2.setExpression("Placement.Base.x", f"{autoGeneratedLabel}.array2XPos")  # type: ignore
            row2.setExpression("Placement.Base.y", f"{autoGeneratedLabel}.array2YPos")  # type: ignore

            for arr in (row1, row2):
                arr.setExpression("IntervalX.x", f"{autoGeneratedLabel}.xInterval")  # type: ignore
                arr.setExpression("IntervalY.y", f"{autoGeneratedLabel}.yInterval")  # type: ignore
                arr.setExpression("NumberX", f"{autoGeneratedLabel}.countX")  # type: ignore
                arr.setExpression("NumberY", f"{autoGeneratedLabel}.countY")  # type: ignore

            # 4) Use a Compound instead of a MultiFuse (faster, enough for cutting)
            compound = doc.addObject("Part::Compound", "HoneycombCompound")
            compound.Links = [row1, row2]  # accepts arrays/links directly

            hexagon.ViewObject.Visibility = False
            row1.ViewObject.Visibility = False  # type: ignore
            row2.ViewObject.Visibility = False  # type: ignore

        finally:
            if hasattr(doc, "AutoRecompute"):
                doc.AutoRecompute = had_autorc
            doc.recompute()  # one-shot recompute

        self.fusedArrays = compound
        return compound

    def align(self, reference, target=None):
        if target is None:
            target = self.fusedArrays
        referencePlacement = reference.getGlobalPlacement()
        targetPlacement = target.getGlobalPlacement()

        referenceFace = reference.Shape.Faces[0]
        referenceWire = referenceFace.OuterWire
        referencePoints = np.array([
            [referencePlacement.multVec(v.Point).x,
            referencePlacement.multVec(v.Point).y,
            referencePlacement.multVec(v.Point).z]
            for v in referenceWire.Vertexes
        ])

        referencePoints = referencePoints[::2]
        targetPoints = np.array([
            [targetPlacement.multVec(v.Point).x,
            targetPlacement.multVec(v.Point).y,
            targetPlacement.multVec(v.Point).z]
            for v in list(target.Shape.Vertexes)[:4]
        ])

        if len(referencePoints) != len(targetPoints):
            raise RuntimeError(
                f"Point count mismatch: reference={len(referencePoints)}, target={len(targetPoints)}"
            )

        referenceMean = referencePoints.mean(axis=0)
        targetMean = targetPoints.mean(axis=0)
        P = referencePoints - referenceMean
        Q = targetPoints - targetMean

        H = Q.T @ P
        U, S, Vt = np.linalg.svd(H)
        R = Vt.T @ U.T
        if np.linalg.det(R) < 0:
            Vt[-1, :] *= -1
            R = Vt.T @ U.T

        m = App.Matrix(
            R[0,0], R[0,1], R[0,2], 0,
            R[1,0], R[1,1], R[1,2], 0,
            R[2,0], R[2,1], R[2,2], 0,
            0,      0,      0,      1
        )
        rot = App.Rotation(m)

        targetVector = App.Vector(*targetMean)
        referenceVector = App.Vector(*referenceMean)
        translation = referenceVector - rot.multVec(targetVector)
        target.Placement = App.Placement(translation, rot)
        referenceCenter = reference.Shape.CenterOfGravity
        targetCenter = target.Shape.CenterOfGravity
        placement = target.Placement
        placement.Base = placement.Base.add(referenceCenter.sub(targetCenter))
        target.Placement = placement
        App.ActiveDocument.recompute()

        return target


    def extrude(self, length=None):
        extruded = App.ActiveDocument.addObject("Part::Extrusion", "Extruded")
        extruded.Base = self.fusedArrays
        extruded.DirMode = "Normal"
        extruded.Solid = True

        if length is None:
            # Bind directly to spreadsheet value (userSheetLabel.height)
            extruded.setExpression("LengthFwd", f"{self.userSheet.Label}.height")
            extruded.LengthRev = 0  # avoid conflict
        else:
            # Handle explicit numeric input
            extruded.LengthFwd = length if length > 0 else 0
            extruded.LengthRev = -length if length < 0 else 0

        return extruded

    @staticmethod
    def getGlobalRotation(plane):
        globalRotation = getattr(plane, "getGlobalPlacement", None)
        if callable(globalRotation):
            return globalRotation().Rotation  # type: ignore
        return plane.Placement.Rotation

    @staticmethod
    def getDeltaRotation(reference, target):
        baseRotation = App.Rotation(reference)
        baseRotation.invert()
        return baseRotation.multiply(target)
    
    