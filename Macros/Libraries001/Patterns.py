import math

import Draft
import FreeCAD as App
import FreeCADGui as Gui
import numpy as np
from PySide import QtCore

from Libraries001.Transformation import Points

hexSeparation = 0.2
hexExtrusion = -2
hexRadius = 2
planeOffset = -3
userSheetLabel = "EditMe"
autoGeneratedLabel = "AutoGenerated"


class ShapePattern:
    def __init__(self, userSheet, autoGeneratedSheet, offset2D, type):
        self.autoGeneratedSheet = autoGeneratedSheet
        self.type = type or "hexagons"
        self.userSheet = userSheet
        self.offset2D = offset2D
        self.fusedArrays = None
        self.K = []

    def create(self):
        doc = App.ActiveDocument

        # ---- Defer recomputes until the end
        had_autorc = getattr(doc, "AutoRecompute", True)
        if hasattr(doc, "AutoRecompute"):
            doc.AutoRecompute = False
        try:
            # 1) Hex profile driven by user sheet
            hexagon = doc.addObject("Part::RegularPolygon", "HoneycombHexagon")
            hexagon.Polygon = 6
            hexagon.setExpression("Circumradius", f"{userSheetLabel}.radius")
                    # recompute to make shape usable
            doc.recompute()

            self.hexagon = np.array([[v.X, v.Y, v.Z] for v in hexagon.Shape.Vertexes])
            row1 = Draft.make_ortho_array(
                hexagon,
                v_x=App.Vector(1, 0, 0),
                v_y=App.Vector(0, 1, 0),
                n_x=1,
                n_y=1,
                use_link=True,
            )

            row2 = Draft.make_ortho_array(
                hexagon,
                v_x=App.Vector(1, 0, 0),
                v_y=App.Vector(0, 1, 0),
                n_x=1,
                n_y=1,
                use_link=True,
            )

            row2.setExpression("Placement.Base.x", f"{autoGeneratedLabel}.array2XPos")  # type: ignore
            row2.setExpression("Placement.Base.y", f"{autoGeneratedLabel}.array2YPos")  # type: ignore

            for arr in (row1, row2):
                arr.setExpression("IntervalX.x", f"{autoGeneratedLabel}.xInterval")  # type: ignore
                arr.setExpression("IntervalY.y", f"{autoGeneratedLabel}.yInterval")  # type: ignore
                arr.setExpression("NumberX", f"{autoGeneratedLabel}.countX")  # type: ignore
                arr.setExpression("NumberY", f"{autoGeneratedLabel}.countY")  # type: ignore

            # 4) Use a Compound instead of a MultiFuse (faster, enough for cutting)
            compound = doc.addObject("Part::Compound", "HoneycombCompound")
            compound.Links = [row1, row2]  # accepts arrays/links directly

            hexagon.ViewObject.Visibility = False
            row1.ViewObject.Visibility = False  # type: ignore
            row2.ViewObject.Visibility = False  # type: ignore

        finally:
            if hasattr(doc, "AutoRecompute"):
                doc.AutoRecompute = had_autorc
            doc.recompute()  # one-shot recompute

        self.fusedArrays = compound
        return compound
    
    def align(self, reference, target=None, point=None):
        if target is None and self.fusedArrays is not None:
            target = self.fusedArrays

        # 1. Get the reference face and its properties
        referenceFace = reference.Shape.Faces[0]
        referencePoints = np.array([[v.X, v.Y, v.Z] for v in referenceFace.Vertexes])
        # The SIMPLE and CORRECT way to get the target position
        referenceCenter = referenceFace.CenterOfMass

        # 2. Use your Points class to get the rotation matrix R. This part is perfect.
        # We pass self.hexagon as the target because it represents the object's original flat state.
        points = Points(referencePoints, self.hexagon, point)
        R = points.compute()

        # 3. Convert the NumPy matrix R into a FreeCAD Rotation object
        # Your method of creating a Rotation from the matrix columns is correct.
        rotation = App.Rotation(
            App.Vector(R[0,0], R[1,0], R[2,0]),
            App.Vector(R[0,1], R[1,1], R[2,1]),
            App.Vector(R[0,2], R[1,2], R[2,2]),
        )

        # 4. Create the new ABSOLUTE placement
        # The placement is defined by the target position (referenceCenter) and orientation (rotation).
        new_absolute_placement = App.Placement(referenceCenter, rotation)

        # 5. SET the object's placement directly. Do NOT multiply.
        target.Placement = new_absolute_placement
        
        App.ActiveDocument.recompute()
        return target




    def extrude(self, length=None):
        extruded = App.ActiveDocument.addObject("Part::Extrusion", "Extruded")
        extruded.Base = self.fusedArrays
        extruded.DirMode = "Normal"
        extruded.Solid = True

        if length is None:
            # Bind directly to spreadsheet value (userSheetLabel.height)
            extruded.setExpression("LengthFwd", f"{self.userSheet.Label}.height")
            extruded.LengthRev = 0  # avoid conflict
        else:
            # Handle explicit numeric input
            extruded.LengthFwd = length if length > 0 else 0
            extruded.LengthRev = -length if length < 0 else 0

        return extruded

    @staticmethod
    def getGlobalRotation(plane):
        globalRotation = getattr(plane, "getGlobalPlacement", None)
        if callable(globalRotation):
            return globalRotation().Rotation  # type: ignore
        return plane.Placement.Rotation

    @staticmethod
    def getDeltaRotation(reference, target):
        baseRotation = App.Rotation(reference)
        baseRotation.invert()
        return baseRotation.multiply(target)
