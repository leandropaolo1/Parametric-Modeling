import FreeCADGui as Gui
import FreeCAD as App
import Draft
import math
from PySide import QtCore
import numpy as np
from RodriguezTransformation import Points

hexSeparation       = .2
hexExtrusion        = -2
hexRadius           = 2
planeOffset         = -3
userSheetLabel      = 'EditMe'
autoGeneratedLabel  = 'AutoGenerated'



class ShapePattern():
    def __init__(self, userSheet, autoGeneratedSheet, offset2D, type):
        self.autoGeneratedSheet = autoGeneratedSheet
        self.type = type or 'hexagons'
        self.userSheet = userSheet
        self.offset2D = offset2D
        self.fusedArrays = None
        self.K = []
        

    def supportShape(self, src_obj, subname):
        """
        Return the exact Face referenced by `subname` from `src_obj.Shape`,
        tolerating odd formats (e.g. ('Face3',), 'Face', etc.).
        """
        shp = src_obj.Shape

        # Normalize subname to a simple string like "FaceN"
        if isinstance(subname, (tuple, list)) and subname:
            subname = subname[0]

        # 1) Try direct lookup (best case)
        try:
            return shp.getElement(subname)
        except Exception:
            pass

        # 2) Parse trailing digits and index the Faces list
        try:
            import re
            m = re.search(r'(\d+)$', str(subname))
            if m:
                i = int(m.group(1)) - 1
                if 0 <= i < len(shp.Faces):
                    return shp.Faces[i]
        except Exception:
            pass

        # 3) Fallback: first face
        return shp.Faces[0] if shp.Faces else None

        
    def create(self):
        doc = App.ActiveDocument

        # ---- Defer recomputes until the end
        had_autorc = getattr(doc, "AutoRecompute", True)
        if hasattr(doc, "AutoRecompute"):
            doc.AutoRecompute = False
        try:
            # 1) Hex profile driven by user sheet
            hexagon = doc.addObject("Part::RegularPolygon", "HoneycombHexagon")
            hexagon.Polygon = 6
            hexagon.setExpression('Circumradius', f'{userSheetLabel}.radius')

            # 3) Two ortho arrays as *links* (memory-friendly)
            row1 = Draft.make_ortho_array(
                hexagon,
                v_x=App.Vector(1, 0, 0),
                v_y=App.Vector(0, 1, 0),
                n_x=1, n_y=1, use_link=True)

            row2 = Draft.make_ortho_array(
                hexagon,
                v_x=App.Vector(1, 0, 0),
                v_y=App.Vector(0, 1, 0),
                n_x=1, n_y=1, use_link=True)

            row2.setExpression('Placement.Base.x', f'{autoGeneratedLabel}.array2XPos') # type: ignore
            row2.setExpression('Placement.Base.y', f'{autoGeneratedLabel}.array2YPos') # type: ignore
            for arr in (row1, row2):
                arr.setExpression('IntervalX.x', f'{autoGeneratedLabel}.xInterval') # type: ignore
                arr.setExpression('IntervalY.y', f'{autoGeneratedLabel}.yInterval') # type: ignore
                arr.setExpression('NumberX',     f'{autoGeneratedLabel}.countX') # type: ignore
                arr.setExpression('NumberY',     f'{autoGeneratedLabel}.countY') # type: ignore

            # 4) Use a Compound instead of a MultiFuse (faster, enough for cutting)
            compound = doc.addObject("Part::Compound", "HoneycombCompound")
            compound.Links = [row1, row2]  # accepts arrays/links directly

            hexagon.ViewObject.Visibility = False
            row1.ViewObject.Visibility = False # type: ignore
            row2.ViewObject.Visibility = False # type: ignore

        finally:
            if hasattr(doc, "AutoRecompute"):
                doc.AutoRecompute = had_autorc
            doc.recompute()  # one-shot recompute

        # Store and hand back the single tool weâ€™ll cut with
        self.fusedArrays = compound
        return compound

    def align(self, reference, target=None, point = None):
        if target is None and self.fusedArrays is not None:
            target = self.fusedArrays
        referenceFace = reference.Shape.Faces[0]
        referencePoints = np.array([[v.X, v.Y, v.Z] for v in referenceFace.Vertexes])
        bb = target.Shape.BoundBox # type: ignore
        targetPoints = np.array([
            [bb.XMin, bb.YMin, bb.ZMin],
            [bb.XMin, bb.YMin, bb.ZMax],
            [bb.XMin, bb.YMax, bb.ZMin],
            [bb.XMin, bb.YMax, bb.ZMax],
            [bb.XMax, bb.YMin, bb.ZMin],
            [bb.XMax, bb.YMin, bb.ZMax],
            [bb.XMax, bb.YMax, bb.ZMin],
            [bb.XMax, bb.YMax, bb.ZMax],
        ])
        
        points = Points(referencePoints, targetPoints, point)
        R = points.compute()
        newTarget = points.target @ R.T
        newTargetTranslation = points.point - newTarget.mean(axis=0)
        alignedNewTarget = newTarget + newTargetTranslation

        rot = App.Rotation(
            App.Vector(R[0,0], R[1,0], R[2,0]),
            App.Vector(R[0,1], R[1,1], R[2,1]),
            App.Vector(R[0,2], R[1,2], R[2,2])
        )
        vec = App.Vector(*newTargetTranslation)

        target.Placement = App.Placement(vec, rot) # type: ignore

        return target

    def extrude(self, length):
        extruded = App.ActiveDocument.addObject('Part::Extrusion', 'Extruded')
        extruded.Base = self.fusedArrays
        extruded.DirMode = "Normal"
        extruded.LengthFwd = length if length > 0 else 0
        extruded.LengthRev = -length if length < 0 else 0
        extruded.Solid = True
        return extruded

     
    @staticmethod
    def getGlobalRotation(plane):
        globalRotation = getattr(plane, "getGlobalPlacement", None)
        if callable(globalRotation):
            return globalRotation().Rotation  # type: ignore
        return plane.Placement.Rotation

    @staticmethod
    def getDeltaRotation(reference, target):
        baseRotation = App.Rotation(reference)
        baseRotation.invert()
        return baseRotation.multiply(target)

