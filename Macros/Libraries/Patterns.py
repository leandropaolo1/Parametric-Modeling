import math

import Draft
import FreeCAD as App
import FreeCADGui as Gui
import numpy as np
from PySide import QtCore

from Libraries.Transformation import Points

hexSeparation = 0.2
hexExtrusion = -2
hexRadius = 2
planeOffset = -3
userSheetLabel = "EditMe"
autoGeneratedLabel = "AutoGenerated"


class ShapePattern:
    def __init__(self, userSheet, autoGeneratedSheet, offset2D, type):
        self.autoGeneratedSheet = autoGeneratedSheet
        self.type = type or "hexagons"
        self.userSheet = userSheet
        self.offset2D = offset2D
        self.fusedArrays = None
        self.K = []

    def create(self):
        doc = App.ActiveDocument

        # ---- Defer recomputes until the end
        had_autorc = getattr(doc, "AutoRecompute", True)
        if hasattr(doc, "AutoRecompute"):
            doc.AutoRecompute = False
        try:
            # 1) Hex profile driven by user sheet
            hexagon = doc.addObject("Part::RegularPolygon", "HoneycombHexagon")
            hexagon.Polygon = 6
            hexagon.setExpression("Circumradius", f"{userSheetLabel}.radius")

            # 3) Two ortho arrays as *links* (memory-friendly)
            row1 = Draft.make_ortho_array(
                hexagon,
                v_x=App.Vector(1, 0, 0),
                v_y=App.Vector(0, 1, 0),
                n_x=1,
                n_y=1,
                use_link=True,
            )

            row2 = Draft.make_ortho_array(
                hexagon,
                v_x=App.Vector(1, 0, 0),
                v_y=App.Vector(0, 1, 0),
                n_x=1,
                n_y=1,
                use_link=True,
            )

            row2.setExpression("Placement.Base.x", f"{autoGeneratedLabel}.array2XPos")  # type: ignore
            row2.setExpression("Placement.Base.y", f"{autoGeneratedLabel}.array2YPos")  # type: ignore

            for arr in (row1, row2):
                arr.setExpression("IntervalX.x", f"{autoGeneratedLabel}.xInterval")  # type: ignore
                arr.setExpression("IntervalY.y", f"{autoGeneratedLabel}.yInterval")  # type: ignore
                arr.setExpression("NumberX", f"{autoGeneratedLabel}.countX")  # type: ignore
                arr.setExpression("NumberY", f"{autoGeneratedLabel}.countY")  # type: ignore

            # 4) Use a Compound instead of a MultiFuse (faster, enough for cutting)
            compound = doc.addObject("Part::Compound", "HoneycombCompound")
            compound.Links = [row1, row2]  # accepts arrays/links directly

            hexagon.ViewObject.Visibility = False
            row1.ViewObject.Visibility = False  # type: ignore
            row2.ViewObject.Visibility = False  # type: ignore

        finally:
            if hasattr(doc, "AutoRecompute"):
                doc.AutoRecompute = had_autorc

        # Store and hand back the single tool we’ll cut with
        self.fusedArrays = compound
        return compound

    def align(self, reference, target=None, point=None):
        if target is None and self.fusedArrays is not None:
            target = self.fusedArrays

        referenceFace = reference.Shape.Faces[0]
        referencePoints = np.array([[v.X, v.Y, v.Z] for v in referenceFace.Vertexes])
        bb = target.Shape.BoundBox  # type: ignore
        targetPoints = np.array(
            [
                [bb.XMin, bb.YMin, bb.ZMin],
                [bb.XMin, bb.YMin, bb.ZMax],
                [bb.XMin, bb.YMax, bb.ZMin],
                [bb.XMin, bb.YMax, bb.ZMax],
                [bb.XMax, bb.YMin, bb.ZMin],
                [bb.XMax, bb.YMin, bb.ZMax],
                [bb.XMax, bb.YMax, bb.ZMin],
                [bb.XMax, bb.YMax, bb.ZMax],
            ]
        )

        points = Points(referencePoints, targetPoints, point)
        R = points.compute()
        newTarget = points.target @ R.T

        # Rotation from numpy → FreeCAD
        rotation = App.Rotation(
            App.Vector(R[0, 0], R[1, 0], R[2, 0]),
            App.Vector(R[0, 1], R[1, 1], R[2, 1]),
            App.Vector(R[0, 2], R[1, 2], R[2, 2]),
        )

        # Apply rotation relative to current placement
        currentPlacement = target.Placement
        newPlacement = App.Placement(App.Vector(0, 0, 0), rotation)
        target.Placement = currentPlacement.multiply(newPlacement)

        # --- Now align centers of gravity ---
        targetCenter = target.Shape.CenterOfGravity
        referenceCenter = reference.Shape.CenterOfGravity
        delta = referenceCenter.sub(targetCenter)

        # Shift target so centers match
        target.Placement.Base += delta

        App.Console.PrintMessage(
            "[align] Target center before: {}\n".format(targetCenter)
        )
        App.Console.PrintMessage(
            "[align] Reference center: {}\n".format(referenceCenter)
        )
        App.Console.PrintMessage("[align] Applied delta: {}\n".format(delta))
        App.Console.PrintMessage(
            "[align] New target base: {}\n".format(target.Placement.Base)
        )

        # Final placement info
        App.Console.PrintMessage(
            "[align] Final placement: {}\n".format(target.Placement)
        )

        return target

    def extrude(self, length=None):
        extruded = App.ActiveDocument.addObject("Part::Extrusion", "Extruded")
        extruded.Base = self.fusedArrays
        extruded.DirMode = "Normal"
        extruded.Solid = True

        if length is None:
            # Bind directly to spreadsheet value (userSheetLabel.height)
            extruded.setExpression("LengthFwd", f"{self.userSheet.Label}.height")
            extruded.LengthRev = 0  # avoid conflict
        else:
            # Handle explicit numeric input
            extruded.LengthFwd = length if length > 0 else 0
            extruded.LengthRev = -length if length < 0 else 0

        return extruded

    @staticmethod
    def getGlobalRotation(plane):
        globalRotation = getattr(plane, "getGlobalPlacement", None)
        if callable(globalRotation):
            return globalRotation().Rotation  # type: ignore
        return plane.Placement.Rotation

    @staticmethod
    def getDeltaRotation(reference, target):
        baseRotation = App.Rotation(reference)
        baseRotation.invert()
        return baseRotation.multiply(target)
