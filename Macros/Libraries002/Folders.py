import FreeCAD as App

hexSeparation = 0.2
hexExtrusion = -2
hexRadius = 2
planeOffset = -3
userSheetLabel = "EditMe"
autoGeneratedLabel = "AutoGenerated"


class Folders:
    def __init__(self):
        pass

    @staticmethod
    def create(
        container_name: str = "Honeycomb",
        object_names=("EditMe", "Offset2D", "Extruded", "Fused_Arrays"),
        body_name: str = "Body",
        binder_name: str = "Binder",
        use_part: bool = False,
        include_binder_link: bool = True,
    ):
        """
        Create (or reuse) a top-level container and place the generated objects inside it.
        - If use_part is True, an App::Part is created so placement is unified.
        - The Binder stays inside the Body; we optionally show it via an App::Link.
        - Idempotent: won’t re-add already grouped objects or duplicate the link.
        Returns: (container, binder_link or None)
        """
        doc = App.ActiveDocument
        if doc is None:
            raise RuntimeError("No active document.")

        # Pause recompute while we shuffle the tree
        had_autorecompute = getattr(doc, "AutoRecompute", True)
        if hasattr(doc, "AutoRecompute"):
            doc.AutoRecompute = False

        try:
            # 1) Create or reuse the container
            existing = doc.getObject(container_name)
            if existing and (
                existing.TypeId in ("App::DocumentObjectGroup", "App::Part")
            ):
                container = existing
            else:
                # If a different object with that name exists, rename it to avoid conflict
                if existing and existing.TypeId not in (
                    "App::DocumentObjectGroup",
                    "App::Part",
                ):
                    existing.Label = existing.Label + "_old"
                ctype = "App::Part" if use_part else "App::DocumentObjectGroup"
                container = doc.addObject(ctype, container_name)
                container.Label = container_name

            # 2) Optionally place the Body inside the Part (not the Group)
            body = doc.getObject(body_name)
            if use_part and body and body not in getattr(container, "Group", []):
                container.addObject(body)

            # Helper: add an object if it exists and isn’t already inside
            def _safe_add(obj):
                if not obj:
                    return
                if obj is container:
                    return
                current_group = getattr(container, "Group", [])
                if obj not in current_group:
                    container.addObject(obj)

            # 3) Add requested objects (skip Body if already handled)
            for name in object_names:
                obj = doc.getObject(name)
                if use_part and obj is body:
                    continue
                _safe_add(obj)

            # 4) Optionally expose the Binder via an App::Link (don’t move it)
            binder_link = None
            binder = doc.getObject(binder_name)
            if include_binder_link and binder:
                link_name = f"{binder_name}_Link"
                binder_link = doc.getObject(link_name)
                if binder_link is None:
                    binder_link = doc.addObject("App::Link", link_name)
                # Only update if it’s not already linked or links elsewhere
                if getattr(binder_link, "LinkedObject", None) is not binder:
                    binder_link.LinkedObject = binder
                _safe_add(binder_link)

            doc.recompute()
            return container, binder_link

        finally:
            if hasattr(doc, "AutoRecompute"):
                doc.AutoRecompute = had_autorecompute
            doc.recompute()
